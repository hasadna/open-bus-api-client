/* tslint:disable */
/* eslint-disable */
/**
 * Open Bus Stride API
 * ### Follow planned and real-time bus statistics ðŸšŒ  Welcome to The Public Knowledge Workshop\'s Stride project. We provide usable and accurate data about the Israeli public transportation system.  For background on the project and some more detailed documentation and usage guides, see [STRIDE.md](https://github.com/hasadna/open-bus-pipelines/blob/main/STRIDE.md).  Looking for a specific use-case?  * Take a look at the **user cases** APIs below. * Try one of our existing [jupyter notebooks](https://github.com/hasadna/open-bus-stride-client/blob/main/README.md#using-the-interactive-jupyter-notebooks). * Don\'t see your use-case covered here? Please [open us a ticket](https://github.com/login?return_to=https%3A%2F%2Fgithub.com%2Fhasadna%2Fopen-bus%2Fissues%2Fnew)!  Queries are by default limited to 100 results per query, this limit can be increased up to 500,000 results. Please try to set appropriate query parameters to limit the results to reduce load on our DB. If you do need to get large number of results (up to 500,000) it\'s recommended to use one of these methods:  1. Use HTTP streaming and JSON streaming decoder, this method is most efficient and provide accurate results.    Our [Stride Python Client iterate method](https://github.com/hasadna/open-bus-stride-client#usage) uses this method. 2. Use combination of limit / offset parameters to get results by page. This method may be less accurate because    it depends on data remaining unchanged between requests.  For more advanced usage-  * Use **gtfs** for data about the planned lines timetables.  * Use **siri** for data about lines real-time * See [Open Bus Stride Data Model](https://github.com/hasadna/open-bus-stride-db/blob/main/DATA_MODEL.md) for description of field and table names. * See [Open Bus Stride ETL Processes](https://github.com/hasadna/open-bus-pipelines/blob/main/STRIDE_ETL_PROCESSES.md) for description of the ETL processes which fetch and aggregate the data. * See [MOT Developer Information](https://www.gov.il/BlobFolder/generalpage/gtfs_general_transit_feed_specifications/he/GTFS%20-%20Developer%20Information.pdf) for description of the source fields as published by the Israel Ministry of Transportation. 
 *
 * The version of the OpenAPI document: local-development
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import type { HTTPValidationError } from '../models';
// @ts-ignore
import type { RideExecutionPydanticModel } from '../models';
// @ts-ignore
import type { RouteTimetablePydanticModel } from '../models';
// @ts-ignore
import type { StopArrivalPydanticModel } from '../models';
/**
 * UserCasesApi - axios parameter creator
 * @export
 */
export const UserCasesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List of A comparison between the planned and actual rides of a specific route between the given dates. Currently, the \"actual_rides_count\", will be either None (no actual ride) or equal to the \"planned_rides_count.
         * @summary List 
         * @param {string} dateFrom   Filter by date. Only return items which have a date after or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
         * @param {string} dateTo   Filter by date. Only return items which have a date before or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
         * @param {number} [limit] Limit the number of returned results. If not specified will limit to 100 results. To get more results, you can either use the offset param, alternatively - set the limit to -1 and use http streaming with compatible json streaming decoder to get all results, this method can fetch up to a maximum of 500000 results.
         * @param {number} [offset] Item number to start returning results from. Use in combination with limit for pagination, alternatively, don\&#39;t set offset, set limit to -1 and use http streaming with compatible json streaming decoder to get all results up to a maximum of 500000 results.
         * @param {boolean} [getCount] Set to \&quot;true\&quot; to only get the total number of results for given filters. limit/offset/order parameters will be ignored.
         * @param {number} [operatorRef] Line operator ref.  Filter by operator_ref. Only return items which exactly match given string.
         * @param {number} [lineRef] Line ref.  Filter by line_ref. Only return items which exactly match given string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRidesExecutionListGet: async (dateFrom: string, dateTo: string, limit?: number, offset?: number, getCount?: boolean, operatorRef?: number, lineRef?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dateFrom' is not null or undefined
            assertParamExists('listRidesExecutionListGet', 'dateFrom', dateFrom)
            // verify required parameter 'dateTo' is not null or undefined
            assertParamExists('listRidesExecutionListGet', 'dateTo', dateTo)
            const localVarPath = `/rides_execution/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (getCount !== undefined) {
                localVarQueryParameter['get_count'] = getCount;
            }

            if (dateFrom !== undefined) {
                localVarQueryParameter['date_from'] = (dateFrom as any instanceof Date) ?
                    (dateFrom as any).toISOString().substring(0,10) :
                    dateFrom;
            }

            if (dateTo !== undefined) {
                localVarQueryParameter['date_to'] = (dateTo as any instanceof Date) ?
                    (dateTo as any).toISOString().substring(0,10) :
                    dateTo;
            }

            if (operatorRef !== undefined) {
                localVarQueryParameter['operator_ref'] = operatorRef;
            }

            if (lineRef !== undefined) {
                localVarQueryParameter['line_ref'] = lineRef;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List of the stops timetable of a given bus. Currently, only planned time (gtfs) is returned for every stop.
         * @summary List 
         * @param {number} [limit] Limit the number of returned results. If not specified will limit to 100 results. To get more results, you can either use the offset param, alternatively - set the limit to -1 and use http streaming with compatible json streaming decoder to get all results, this method can fetch up to a maximum of 500000 results.
         * @param {number} [offset] Item number to start returning results from. Use in combination with limit for pagination, alternatively, don\&#39;t set offset, set limit to -1 and use http streaming with compatible json streaming decoder to get all results up to a maximum of 500000 results.
         * @param {boolean} [getCount] Set to \&quot;true\&quot; to only get the total number of results for given filters. limit/offset/order parameters will be ignored.
         * @param {string} [plannedStartTimeDateFrom] Set a time range to get the timetable of a specific ride  Filter by planned_start_time. Only return items which have date/time after or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
         * @param {string} [plannedStartTimeDateTo] Set a time range to get the time table of a specific ride  Filter by planned_start_time. Only return items which have date/time before or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
         * @param {string} [lineRefs] To get a line ref, first query gtfs_routes  Filter by line_ref. Comma-separated list of values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRouteTimetableListGet: async (limit?: number, offset?: number, getCount?: boolean, plannedStartTimeDateFrom?: string, plannedStartTimeDateTo?: string, lineRefs?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/route_timetable/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (getCount !== undefined) {
                localVarQueryParameter['get_count'] = getCount;
            }

            if (plannedStartTimeDateFrom !== undefined) {
                localVarQueryParameter['planned_start_time_date_from'] = (plannedStartTimeDateFrom as any instanceof Date) ?
                    (plannedStartTimeDateFrom as any).toISOString() :
                    plannedStartTimeDateFrom;
            }

            if (plannedStartTimeDateTo !== undefined) {
                localVarQueryParameter['planned_start_time_date_to'] = (plannedStartTimeDateTo as any instanceof Date) ?
                    (plannedStartTimeDateTo as any).toISOString() :
                    plannedStartTimeDateTo;
            }

            if (lineRefs !== undefined) {
                localVarQueryParameter['line_refs'] = lineRefs;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List of the actual arrival times to a specific stop. Currently, only planned time (gtfs) is returned for every stop.
         * @summary List 
         * @param {number} [limit] Limit the number of returned results. If not specified will limit to 100 results. To get more results, you can either use the offset param, alternatively - set the limit to -1 and use http streaming with compatible json streaming decoder to get all results, this method can fetch up to a maximum of 500000 results.
         * @param {number} [offset] Item number to start returning results from. Use in combination with limit for pagination, alternatively, don\&#39;t set offset, set limit to -1 and use http streaming with compatible json streaming decoder to get all results up to a maximum of 500000 results.
         * @param {boolean} [getCount] Set to \&quot;true\&quot; to only get the total number of results for given filters. limit/offset/order parameters will be ignored.
         * @param {number} [gtfsStopId] To get a line ref, first query gtfs_routes  Filter by gtfs_stop_id. Only return items which exactly match given string.
         * @param {string} [gtfsRideIds] To get a line ref, first query gtfs_routes  Filter by line_ref. Comma-separated list of values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listStopArrivalsListGet: async (limit?: number, offset?: number, getCount?: boolean, gtfsStopId?: number, gtfsRideIds?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/stop_arrivals/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (getCount !== undefined) {
                localVarQueryParameter['get_count'] = getCount;
            }

            if (gtfsStopId !== undefined) {
                localVarQueryParameter['gtfs_stop_id'] = gtfsStopId;
            }

            if (gtfsRideIds !== undefined) {
                localVarQueryParameter['gtfs_ride_ids'] = gtfsRideIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserCasesApi - functional programming interface
 * @export
 */
export const UserCasesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserCasesApiAxiosParamCreator(configuration)
    return {
        /**
         * List of A comparison between the planned and actual rides of a specific route between the given dates. Currently, the \"actual_rides_count\", will be either None (no actual ride) or equal to the \"planned_rides_count.
         * @summary List 
         * @param {string} dateFrom   Filter by date. Only return items which have a date after or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
         * @param {string} dateTo   Filter by date. Only return items which have a date before or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
         * @param {number} [limit] Limit the number of returned results. If not specified will limit to 100 results. To get more results, you can either use the offset param, alternatively - set the limit to -1 and use http streaming with compatible json streaming decoder to get all results, this method can fetch up to a maximum of 500000 results.
         * @param {number} [offset] Item number to start returning results from. Use in combination with limit for pagination, alternatively, don\&#39;t set offset, set limit to -1 and use http streaming with compatible json streaming decoder to get all results up to a maximum of 500000 results.
         * @param {boolean} [getCount] Set to \&quot;true\&quot; to only get the total number of results for given filters. limit/offset/order parameters will be ignored.
         * @param {number} [operatorRef] Line operator ref.  Filter by operator_ref. Only return items which exactly match given string.
         * @param {number} [lineRef] Line ref.  Filter by line_ref. Only return items which exactly match given string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRidesExecutionListGet(dateFrom: string, dateTo: string, limit?: number, offset?: number, getCount?: boolean, operatorRef?: number, lineRef?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RideExecutionPydanticModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRidesExecutionListGet(dateFrom, dateTo, limit, offset, getCount, operatorRef, lineRef, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserCasesApi.listRidesExecutionListGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List of the stops timetable of a given bus. Currently, only planned time (gtfs) is returned for every stop.
         * @summary List 
         * @param {number} [limit] Limit the number of returned results. If not specified will limit to 100 results. To get more results, you can either use the offset param, alternatively - set the limit to -1 and use http streaming with compatible json streaming decoder to get all results, this method can fetch up to a maximum of 500000 results.
         * @param {number} [offset] Item number to start returning results from. Use in combination with limit for pagination, alternatively, don\&#39;t set offset, set limit to -1 and use http streaming with compatible json streaming decoder to get all results up to a maximum of 500000 results.
         * @param {boolean} [getCount] Set to \&quot;true\&quot; to only get the total number of results for given filters. limit/offset/order parameters will be ignored.
         * @param {string} [plannedStartTimeDateFrom] Set a time range to get the timetable of a specific ride  Filter by planned_start_time. Only return items which have date/time after or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
         * @param {string} [plannedStartTimeDateTo] Set a time range to get the time table of a specific ride  Filter by planned_start_time. Only return items which have date/time before or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
         * @param {string} [lineRefs] To get a line ref, first query gtfs_routes  Filter by line_ref. Comma-separated list of values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRouteTimetableListGet(limit?: number, offset?: number, getCount?: boolean, plannedStartTimeDateFrom?: string, plannedStartTimeDateTo?: string, lineRefs?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RouteTimetablePydanticModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRouteTimetableListGet(limit, offset, getCount, plannedStartTimeDateFrom, plannedStartTimeDateTo, lineRefs, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserCasesApi.listRouteTimetableListGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List of the actual arrival times to a specific stop. Currently, only planned time (gtfs) is returned for every stop.
         * @summary List 
         * @param {number} [limit] Limit the number of returned results. If not specified will limit to 100 results. To get more results, you can either use the offset param, alternatively - set the limit to -1 and use http streaming with compatible json streaming decoder to get all results, this method can fetch up to a maximum of 500000 results.
         * @param {number} [offset] Item number to start returning results from. Use in combination with limit for pagination, alternatively, don\&#39;t set offset, set limit to -1 and use http streaming with compatible json streaming decoder to get all results up to a maximum of 500000 results.
         * @param {boolean} [getCount] Set to \&quot;true\&quot; to only get the total number of results for given filters. limit/offset/order parameters will be ignored.
         * @param {number} [gtfsStopId] To get a line ref, first query gtfs_routes  Filter by gtfs_stop_id. Only return items which exactly match given string.
         * @param {string} [gtfsRideIds] To get a line ref, first query gtfs_routes  Filter by line_ref. Comma-separated list of values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listStopArrivalsListGet(limit?: number, offset?: number, getCount?: boolean, gtfsStopId?: number, gtfsRideIds?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StopArrivalPydanticModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listStopArrivalsListGet(limit, offset, getCount, gtfsStopId, gtfsRideIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserCasesApi.listStopArrivalsListGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserCasesApi - factory interface
 * @export
 */
export const UserCasesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserCasesApiFp(configuration)
    return {
        /**
         * List of A comparison between the planned and actual rides of a specific route between the given dates. Currently, the \"actual_rides_count\", will be either None (no actual ride) or equal to the \"planned_rides_count.
         * @summary List 
         * @param {string} dateFrom   Filter by date. Only return items which have a date after or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
         * @param {string} dateTo   Filter by date. Only return items which have a date before or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
         * @param {number} [limit] Limit the number of returned results. If not specified will limit to 100 results. To get more results, you can either use the offset param, alternatively - set the limit to -1 and use http streaming with compatible json streaming decoder to get all results, this method can fetch up to a maximum of 500000 results.
         * @param {number} [offset] Item number to start returning results from. Use in combination with limit for pagination, alternatively, don\&#39;t set offset, set limit to -1 and use http streaming with compatible json streaming decoder to get all results up to a maximum of 500000 results.
         * @param {boolean} [getCount] Set to \&quot;true\&quot; to only get the total number of results for given filters. limit/offset/order parameters will be ignored.
         * @param {number} [operatorRef] Line operator ref.  Filter by operator_ref. Only return items which exactly match given string.
         * @param {number} [lineRef] Line ref.  Filter by line_ref. Only return items which exactly match given string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRidesExecutionListGet(dateFrom: string, dateTo: string, limit?: number, offset?: number, getCount?: boolean, operatorRef?: number, lineRef?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<RideExecutionPydanticModel>> {
            return localVarFp.listRidesExecutionListGet(dateFrom, dateTo, limit, offset, getCount, operatorRef, lineRef, options).then((request) => request(axios, basePath));
        },
        /**
         * List of the stops timetable of a given bus. Currently, only planned time (gtfs) is returned for every stop.
         * @summary List 
         * @param {number} [limit] Limit the number of returned results. If not specified will limit to 100 results. To get more results, you can either use the offset param, alternatively - set the limit to -1 and use http streaming with compatible json streaming decoder to get all results, this method can fetch up to a maximum of 500000 results.
         * @param {number} [offset] Item number to start returning results from. Use in combination with limit for pagination, alternatively, don\&#39;t set offset, set limit to -1 and use http streaming with compatible json streaming decoder to get all results up to a maximum of 500000 results.
         * @param {boolean} [getCount] Set to \&quot;true\&quot; to only get the total number of results for given filters. limit/offset/order parameters will be ignored.
         * @param {string} [plannedStartTimeDateFrom] Set a time range to get the timetable of a specific ride  Filter by planned_start_time. Only return items which have date/time after or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
         * @param {string} [plannedStartTimeDateTo] Set a time range to get the time table of a specific ride  Filter by planned_start_time. Only return items which have date/time before or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
         * @param {string} [lineRefs] To get a line ref, first query gtfs_routes  Filter by line_ref. Comma-separated list of values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRouteTimetableListGet(limit?: number, offset?: number, getCount?: boolean, plannedStartTimeDateFrom?: string, plannedStartTimeDateTo?: string, lineRefs?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<RouteTimetablePydanticModel>> {
            return localVarFp.listRouteTimetableListGet(limit, offset, getCount, plannedStartTimeDateFrom, plannedStartTimeDateTo, lineRefs, options).then((request) => request(axios, basePath));
        },
        /**
         * List of the actual arrival times to a specific stop. Currently, only planned time (gtfs) is returned for every stop.
         * @summary List 
         * @param {number} [limit] Limit the number of returned results. If not specified will limit to 100 results. To get more results, you can either use the offset param, alternatively - set the limit to -1 and use http streaming with compatible json streaming decoder to get all results, this method can fetch up to a maximum of 500000 results.
         * @param {number} [offset] Item number to start returning results from. Use in combination with limit for pagination, alternatively, don\&#39;t set offset, set limit to -1 and use http streaming with compatible json streaming decoder to get all results up to a maximum of 500000 results.
         * @param {boolean} [getCount] Set to \&quot;true\&quot; to only get the total number of results for given filters. limit/offset/order parameters will be ignored.
         * @param {number} [gtfsStopId] To get a line ref, first query gtfs_routes  Filter by gtfs_stop_id. Only return items which exactly match given string.
         * @param {string} [gtfsRideIds] To get a line ref, first query gtfs_routes  Filter by line_ref. Comma-separated list of values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listStopArrivalsListGet(limit?: number, offset?: number, getCount?: boolean, gtfsStopId?: number, gtfsRideIds?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<StopArrivalPydanticModel>> {
            return localVarFp.listStopArrivalsListGet(limit, offset, getCount, gtfsStopId, gtfsRideIds, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserCasesApi - object-oriented interface
 * @export
 * @class UserCasesApi
 * @extends {BaseAPI}
 */
export class UserCasesApi extends BaseAPI {
    /**
     * List of A comparison between the planned and actual rides of a specific route between the given dates. Currently, the \"actual_rides_count\", will be either None (no actual ride) or equal to the \"planned_rides_count.
     * @summary List 
     * @param {string} dateFrom   Filter by date. Only return items which have a date after or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
     * @param {string} dateTo   Filter by date. Only return items which have a date before or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
     * @param {number} [limit] Limit the number of returned results. If not specified will limit to 100 results. To get more results, you can either use the offset param, alternatively - set the limit to -1 and use http streaming with compatible json streaming decoder to get all results, this method can fetch up to a maximum of 500000 results.
     * @param {number} [offset] Item number to start returning results from. Use in combination with limit for pagination, alternatively, don\&#39;t set offset, set limit to -1 and use http streaming with compatible json streaming decoder to get all results up to a maximum of 500000 results.
     * @param {boolean} [getCount] Set to \&quot;true\&quot; to only get the total number of results for given filters. limit/offset/order parameters will be ignored.
     * @param {number} [operatorRef] Line operator ref.  Filter by operator_ref. Only return items which exactly match given string.
     * @param {number} [lineRef] Line ref.  Filter by line_ref. Only return items which exactly match given string.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserCasesApi
     */
    public listRidesExecutionListGet(dateFrom: string, dateTo: string, limit?: number, offset?: number, getCount?: boolean, operatorRef?: number, lineRef?: number, options?: RawAxiosRequestConfig) {
        return UserCasesApiFp(this.configuration).listRidesExecutionListGet(dateFrom, dateTo, limit, offset, getCount, operatorRef, lineRef, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List of the stops timetable of a given bus. Currently, only planned time (gtfs) is returned for every stop.
     * @summary List 
     * @param {number} [limit] Limit the number of returned results. If not specified will limit to 100 results. To get more results, you can either use the offset param, alternatively - set the limit to -1 and use http streaming with compatible json streaming decoder to get all results, this method can fetch up to a maximum of 500000 results.
     * @param {number} [offset] Item number to start returning results from. Use in combination with limit for pagination, alternatively, don\&#39;t set offset, set limit to -1 and use http streaming with compatible json streaming decoder to get all results up to a maximum of 500000 results.
     * @param {boolean} [getCount] Set to \&quot;true\&quot; to only get the total number of results for given filters. limit/offset/order parameters will be ignored.
     * @param {string} [plannedStartTimeDateFrom] Set a time range to get the timetable of a specific ride  Filter by planned_start_time. Only return items which have date/time after or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
     * @param {string} [plannedStartTimeDateTo] Set a time range to get the time table of a specific ride  Filter by planned_start_time. Only return items which have date/time before or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
     * @param {string} [lineRefs] To get a line ref, first query gtfs_routes  Filter by line_ref. Comma-separated list of values.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserCasesApi
     */
    public listRouteTimetableListGet(limit?: number, offset?: number, getCount?: boolean, plannedStartTimeDateFrom?: string, plannedStartTimeDateTo?: string, lineRefs?: string, options?: RawAxiosRequestConfig) {
        return UserCasesApiFp(this.configuration).listRouteTimetableListGet(limit, offset, getCount, plannedStartTimeDateFrom, plannedStartTimeDateTo, lineRefs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List of the actual arrival times to a specific stop. Currently, only planned time (gtfs) is returned for every stop.
     * @summary List 
     * @param {number} [limit] Limit the number of returned results. If not specified will limit to 100 results. To get more results, you can either use the offset param, alternatively - set the limit to -1 and use http streaming with compatible json streaming decoder to get all results, this method can fetch up to a maximum of 500000 results.
     * @param {number} [offset] Item number to start returning results from. Use in combination with limit for pagination, alternatively, don\&#39;t set offset, set limit to -1 and use http streaming with compatible json streaming decoder to get all results up to a maximum of 500000 results.
     * @param {boolean} [getCount] Set to \&quot;true\&quot; to only get the total number of results for given filters. limit/offset/order parameters will be ignored.
     * @param {number} [gtfsStopId] To get a line ref, first query gtfs_routes  Filter by gtfs_stop_id. Only return items which exactly match given string.
     * @param {string} [gtfsRideIds] To get a line ref, first query gtfs_routes  Filter by line_ref. Comma-separated list of values.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserCasesApi
     */
    public listStopArrivalsListGet(limit?: number, offset?: number, getCount?: boolean, gtfsStopId?: number, gtfsRideIds?: string, options?: RawAxiosRequestConfig) {
        return UserCasesApiFp(this.configuration).listStopArrivalsListGet(limit, offset, getCount, gtfsStopId, gtfsRideIds, options).then((request) => request(this.axios, this.basePath));
    }
}

