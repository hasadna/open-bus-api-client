/* tslint:disable */
/* eslint-disable */
/**
 * Open Bus Stride API
 * ### Follow planned and real-time bus statistics ðŸšŒ  Welcome to The Public Knowledge Workshop\'s Stride project. We provide usable and accurate data about the Israeli public transportation system.  For background on the project and some more detailed documentation and usage guides, see [STRIDE.md](https://github.com/hasadna/open-bus-pipelines/blob/main/STRIDE.md).  Looking for a specific use-case?  * Take a look at the **user cases** APIs below. * Try one of our existing [jupyter notebooks](https://github.com/hasadna/open-bus-stride-client/blob/main/README.md#using-the-interactive-jupyter-notebooks). * Don\'t see your use-case covered here? Please [open us a ticket](https://github.com/login?return_to=https%3A%2F%2Fgithub.com%2Fhasadna%2Fopen-bus%2Fissues%2Fnew)!  Queries are by default limited to 100 results per query, this limit can be increased up to 500,000 results. Please try to set appropriate query parameters to limit the results to reduce load on our DB. If you do need to get large number of results (up to 500,000) it\'s recommended to use one of these methods:  1. Use HTTP streaming and JSON streaming decoder, this method is most efficient and provide accurate results.    Our [Stride Python Client iterate method](https://github.com/hasadna/open-bus-stride-client#usage) uses this method. 2. Use combination of limit / offset parameters to get results by page. This method may be less accurate because    it depends on data remaining unchanged between requests.  For more advanced usage-  * Use **gtfs** for data about the planned lines timetables.  * Use **siri** for data about lines real-time * See [Open Bus Stride Data Model](https://github.com/hasadna/open-bus-stride-db/blob/main/DATA_MODEL.md) for description of field and table names. * See [Open Bus Stride ETL Processes](https://github.com/hasadna/open-bus-pipelines/blob/main/STRIDE_ETL_PROCESSES.md) for description of the ETL processes which fetch and aggregate the data. * See [MOT Developer Information](https://www.gov.il/BlobFolder/generalpage/gtfs_general_transit_feed_specifications/he/GTFS%20-%20Developer%20Information.pdf) for description of the source fields as published by the Israel Ministry of Transportation. 
 *
 * The version of the OpenAPI document: 27215a215d186e543c9bf70c73529f0a6872483e
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface GtfsAgencyPydanticModel
 */
export interface GtfsAgencyPydanticModel {
    /**
     * 
     * @type {string}
     * @memberof GtfsAgencyPydanticModel
     */
    'date': string;
    /**
     * 
     * @type {number}
     * @memberof GtfsAgencyPydanticModel
     */
    'operator_ref': number;
    /**
     * 
     * @type {string}
     * @memberof GtfsAgencyPydanticModel
     */
    'agency_name': string;
}
/**
 * 
 * @export
 * @interface GtfsRidePydanticModel
 */
export interface GtfsRidePydanticModel {
    /**
     * 
     * @type {number}
     * @memberof GtfsRidePydanticModel
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof GtfsRidePydanticModel
     */
    'gtfs_route_id': number;
    /**
     * 
     * @type {string}
     * @memberof GtfsRidePydanticModel
     */
    'journey_ref'?: string;
    /**
     * 
     * @type {string}
     * @memberof GtfsRidePydanticModel
     */
    'start_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof GtfsRidePydanticModel
     */
    'end_time'?: string;
}
/**
 * 
 * @export
 * @interface GtfsRideStopPydanticModel
 */
export interface GtfsRideStopPydanticModel {
    /**
     * 
     * @type {number}
     * @memberof GtfsRideStopPydanticModel
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof GtfsRideStopPydanticModel
     */
    'gtfs_stop_id': number;
    /**
     * 
     * @type {number}
     * @memberof GtfsRideStopPydanticModel
     */
    'gtfs_ride_id': number;
    /**
     * 
     * @type {string}
     * @memberof GtfsRideStopPydanticModel
     */
    'arrival_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof GtfsRideStopPydanticModel
     */
    'departure_time'?: string;
    /**
     * 
     * @type {number}
     * @memberof GtfsRideStopPydanticModel
     */
    'stop_sequence'?: number;
    /**
     * 
     * @type {number}
     * @memberof GtfsRideStopPydanticModel
     */
    'pickup_type'?: number;
    /**
     * 
     * @type {number}
     * @memberof GtfsRideStopPydanticModel
     */
    'drop_off_type'?: number;
    /**
     * 
     * @type {number}
     * @memberof GtfsRideStopPydanticModel
     */
    'shape_dist_traveled'?: number;
}
/**
 * 
 * @export
 * @interface GtfsRideStopWithRelatedPydanticModel
 */
export interface GtfsRideStopWithRelatedPydanticModel {
    /**
     * 
     * @type {number}
     * @memberof GtfsRideStopWithRelatedPydanticModel
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof GtfsRideStopWithRelatedPydanticModel
     */
    'gtfs_stop_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof GtfsRideStopWithRelatedPydanticModel
     */
    'gtfs_ride_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof GtfsRideStopWithRelatedPydanticModel
     */
    'arrival_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof GtfsRideStopWithRelatedPydanticModel
     */
    'departure_time'?: string;
    /**
     * 
     * @type {number}
     * @memberof GtfsRideStopWithRelatedPydanticModel
     */
    'stop_sequence'?: number;
    /**
     * 
     * @type {number}
     * @memberof GtfsRideStopWithRelatedPydanticModel
     */
    'pickup_type'?: number;
    /**
     * 
     * @type {number}
     * @memberof GtfsRideStopWithRelatedPydanticModel
     */
    'drop_off_type'?: number;
    /**
     * 
     * @type {number}
     * @memberof GtfsRideStopWithRelatedPydanticModel
     */
    'shape_dist_traveled'?: number;
    /**
     * 
     * @type {number}
     * @memberof GtfsRideStopWithRelatedPydanticModel
     */
    'gtfs_ride__gtfs_route_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof GtfsRideStopWithRelatedPydanticModel
     */
    'gtfs_ride__journey_ref'?: string;
    /**
     * 
     * @type {string}
     * @memberof GtfsRideStopWithRelatedPydanticModel
     */
    'gtfs_ride__start_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof GtfsRideStopWithRelatedPydanticModel
     */
    'gtfs_ride__end_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof GtfsRideStopWithRelatedPydanticModel
     */
    'gtfs_stop__date'?: string;
    /**
     * 
     * @type {number}
     * @memberof GtfsRideStopWithRelatedPydanticModel
     */
    'gtfs_stop__code'?: number;
    /**
     * 
     * @type {number}
     * @memberof GtfsRideStopWithRelatedPydanticModel
     */
    'gtfs_stop__lat'?: number;
    /**
     * 
     * @type {number}
     * @memberof GtfsRideStopWithRelatedPydanticModel
     */
    'gtfs_stop__lon'?: number;
    /**
     * 
     * @type {string}
     * @memberof GtfsRideStopWithRelatedPydanticModel
     */
    'gtfs_stop__name'?: string;
    /**
     * 
     * @type {string}
     * @memberof GtfsRideStopWithRelatedPydanticModel
     */
    'gtfs_stop__city'?: string;
    /**
     * 
     * @type {string}
     * @memberof GtfsRideStopWithRelatedPydanticModel
     */
    'gtfs_route__date'?: string;
    /**
     * 
     * @type {number}
     * @memberof GtfsRideStopWithRelatedPydanticModel
     */
    'gtfs_route__line_ref'?: number;
    /**
     * 
     * @type {number}
     * @memberof GtfsRideStopWithRelatedPydanticModel
     */
    'gtfs_route__operator_ref'?: number;
    /**
     * 
     * @type {string}
     * @memberof GtfsRideStopWithRelatedPydanticModel
     */
    'gtfs_route__route_short_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof GtfsRideStopWithRelatedPydanticModel
     */
    'gtfs_route__route_long_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof GtfsRideStopWithRelatedPydanticModel
     */
    'gtfs_route__route_mkt'?: string;
    /**
     * 
     * @type {string}
     * @memberof GtfsRideStopWithRelatedPydanticModel
     */
    'gtfs_route__route_direction'?: string;
    /**
     * 
     * @type {string}
     * @memberof GtfsRideStopWithRelatedPydanticModel
     */
    'gtfs_route__route_alternative'?: string;
    /**
     * 
     * @type {string}
     * @memberof GtfsRideStopWithRelatedPydanticModel
     */
    'gtfs_route__agency_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof GtfsRideStopWithRelatedPydanticModel
     */
    'gtfs_route__route_type'?: string;
}
/**
 * 
 * @export
 * @interface GtfsRideWithRelatedPydanticModel
 */
export interface GtfsRideWithRelatedPydanticModel {
    /**
     * 
     * @type {number}
     * @memberof GtfsRideWithRelatedPydanticModel
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof GtfsRideWithRelatedPydanticModel
     */
    'gtfs_route_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof GtfsRideWithRelatedPydanticModel
     */
    'journey_ref'?: string;
    /**
     * 
     * @type {string}
     * @memberof GtfsRideWithRelatedPydanticModel
     */
    'start_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof GtfsRideWithRelatedPydanticModel
     */
    'end_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof GtfsRideWithRelatedPydanticModel
     */
    'gtfs_route__date'?: string;
    /**
     * 
     * @type {number}
     * @memberof GtfsRideWithRelatedPydanticModel
     */
    'gtfs_route__line_ref'?: number;
    /**
     * 
     * @type {number}
     * @memberof GtfsRideWithRelatedPydanticModel
     */
    'gtfs_route__operator_ref'?: number;
    /**
     * 
     * @type {string}
     * @memberof GtfsRideWithRelatedPydanticModel
     */
    'gtfs_route__route_short_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof GtfsRideWithRelatedPydanticModel
     */
    'gtfs_route__route_long_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof GtfsRideWithRelatedPydanticModel
     */
    'gtfs_route__route_mkt'?: string;
    /**
     * 
     * @type {string}
     * @memberof GtfsRideWithRelatedPydanticModel
     */
    'gtfs_route__route_direction'?: string;
    /**
     * 
     * @type {string}
     * @memberof GtfsRideWithRelatedPydanticModel
     */
    'gtfs_route__route_alternative'?: string;
    /**
     * 
     * @type {string}
     * @memberof GtfsRideWithRelatedPydanticModel
     */
    'gtfs_route__agency_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof GtfsRideWithRelatedPydanticModel
     */
    'gtfs_route__route_type'?: string;
}
/**
 * 
 * @export
 * @interface GtfsRidesAggGroupByPydanticModel
 */
export interface GtfsRidesAggGroupByPydanticModel {
    /**
     * 
     * @type {string}
     * @memberof GtfsRidesAggGroupByPydanticModel
     */
    'gtfs_route_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof GtfsRidesAggGroupByPydanticModel
     */
    'gtfs_route_hour'?: string;
    /**
     * 
     * @type {number}
     * @memberof GtfsRidesAggGroupByPydanticModel
     */
    'operator_ref'?: number;
    /**
     * 
     * @type {string}
     * @memberof GtfsRidesAggGroupByPydanticModel
     */
    'day_of_week'?: string;
    /**
     * 
     * @type {number}
     * @memberof GtfsRidesAggGroupByPydanticModel
     */
    'line_ref'?: number;
    /**
     * 
     * @type {string}
     * @memberof GtfsRidesAggGroupByPydanticModel
     */
    'route_short_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof GtfsRidesAggGroupByPydanticModel
     */
    'route_long_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof GtfsRidesAggGroupByPydanticModel
     */
    'total_routes': number;
    /**
     * 
     * @type {number}
     * @memberof GtfsRidesAggGroupByPydanticModel
     */
    'total_planned_rides': number;
    /**
     * 
     * @type {number}
     * @memberof GtfsRidesAggGroupByPydanticModel
     */
    'total_actual_rides': number;
}
/**
 * 
 * @export
 * @interface GtfsRidesAggPydanticModel
 */
export interface GtfsRidesAggPydanticModel {
    /**
     * 
     * @type {number}
     * @memberof GtfsRidesAggPydanticModel
     */
    'gtfs_route_id': number;
    /**
     * 
     * @type {string}
     * @memberof GtfsRidesAggPydanticModel
     */
    'gtfs_route_hour': string;
    /**
     * 
     * @type {number}
     * @memberof GtfsRidesAggPydanticModel
     */
    'num_planned_rides': number;
    /**
     * 
     * @type {number}
     * @memberof GtfsRidesAggPydanticModel
     */
    'num_actual_rides': number;
    /**
     * 
     * @type {number}
     * @memberof GtfsRidesAggPydanticModel
     */
    'operator_ref': number;
}
/**
 * 
 * @export
 * @interface GtfsRoutePydanticModel
 */
export interface GtfsRoutePydanticModel {
    /**
     * 
     * @type {number}
     * @memberof GtfsRoutePydanticModel
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof GtfsRoutePydanticModel
     */
    'date': string;
    /**
     * 
     * @type {number}
     * @memberof GtfsRoutePydanticModel
     */
    'line_ref': number;
    /**
     * 
     * @type {number}
     * @memberof GtfsRoutePydanticModel
     */
    'operator_ref': number;
    /**
     * 
     * @type {string}
     * @memberof GtfsRoutePydanticModel
     */
    'route_short_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof GtfsRoutePydanticModel
     */
    'route_long_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof GtfsRoutePydanticModel
     */
    'route_mkt'?: string;
    /**
     * 
     * @type {string}
     * @memberof GtfsRoutePydanticModel
     */
    'route_direction'?: string;
    /**
     * 
     * @type {string}
     * @memberof GtfsRoutePydanticModel
     */
    'route_alternative'?: string;
    /**
     * 
     * @type {string}
     * @memberof GtfsRoutePydanticModel
     */
    'agency_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof GtfsRoutePydanticModel
     */
    'route_type'?: string;
}
/**
 * 
 * @export
 * @interface GtfsStopPydanticModel
 */
export interface GtfsStopPydanticModel {
    /**
     * 
     * @type {number}
     * @memberof GtfsStopPydanticModel
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof GtfsStopPydanticModel
     */
    'date': string;
    /**
     * 
     * @type {number}
     * @memberof GtfsStopPydanticModel
     */
    'code': number;
    /**
     * 
     * @type {number}
     * @memberof GtfsStopPydanticModel
     */
    'lat'?: number;
    /**
     * 
     * @type {number}
     * @memberof GtfsStopPydanticModel
     */
    'lon'?: number;
    /**
     * 
     * @type {string}
     * @memberof GtfsStopPydanticModel
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof GtfsStopPydanticModel
     */
    'city'?: string;
}
/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    'detail'?: Array<ValidationError>;
}
/**
 * 
 * @export
 * @interface LocationInner
 */
export interface LocationInner {
}
/**
 * 
 * @export
 * @interface RideExecutionPydanticModel
 */
export interface RideExecutionPydanticModel {
    /**
     * 
     * @type {string}
     * @memberof RideExecutionPydanticModel
     */
    'planned_start_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof RideExecutionPydanticModel
     */
    'actual_start_time'?: string;
    /**
     * 
     * @type {number}
     * @memberof RideExecutionPydanticModel
     */
    'gtfs_ride_id'?: number;
}
/**
 * 
 * @export
 * @interface RouteTimetablePydanticModel
 */
export interface RouteTimetablePydanticModel {
    /**
     * 
     * @type {number}
     * @memberof RouteTimetablePydanticModel
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof RouteTimetablePydanticModel
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof RouteTimetablePydanticModel
     */
    'city'?: string;
    /**
     * 
     * @type {number}
     * @memberof RouteTimetablePydanticModel
     */
    'lon'?: number;
    /**
     * 
     * @type {number}
     * @memberof RouteTimetablePydanticModel
     */
    'lat'?: number;
    /**
     * 
     * @type {string}
     * @memberof RouteTimetablePydanticModel
     */
    'planned_arrival_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof RouteTimetablePydanticModel
     */
    'gtfs_line_ref'?: string;
    /**
     * 
     * @type {string}
     * @memberof RouteTimetablePydanticModel
     */
    'gtfs_line_start_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof RouteTimetablePydanticModel
     */
    'gtfs_ride_id'?: string;
}
/**
 * 
 * @export
 * @interface SiriRidePydanticModel
 */
export interface SiriRidePydanticModel {
    /**
     * 
     * @type {number}
     * @memberof SiriRidePydanticModel
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof SiriRidePydanticModel
     */
    'siri_route_id': number;
    /**
     * 
     * @type {string}
     * @memberof SiriRidePydanticModel
     */
    'journey_ref': string;
    /**
     * 
     * @type {string}
     * @memberof SiriRidePydanticModel
     */
    'scheduled_start_time': string;
    /**
     * 
     * @type {string}
     * @memberof SiriRidePydanticModel
     */
    'vehicle_ref'?: string;
    /**
     * 
     * @type {string}
     * @memberof SiriRidePydanticModel
     */
    'updated_first_last_vehicle_locations'?: string;
    /**
     * 
     * @type {number}
     * @memberof SiriRidePydanticModel
     */
    'first_vehicle_location_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof SiriRidePydanticModel
     */
    'last_vehicle_location_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof SiriRidePydanticModel
     */
    'updated_duration_minutes'?: string;
    /**
     * 
     * @type {number}
     * @memberof SiriRidePydanticModel
     */
    'duration_minutes'?: number;
    /**
     * 
     * @type {number}
     * @memberof SiriRidePydanticModel
     */
    'journey_gtfs_ride_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof SiriRidePydanticModel
     */
    'route_gtfs_ride_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof SiriRidePydanticModel
     */
    'gtfs_ride_id'?: number;
}
/**
 * 
 * @export
 * @interface SiriRideStopPydanticModel
 */
export interface SiriRideStopPydanticModel {
    /**
     * 
     * @type {number}
     * @memberof SiriRideStopPydanticModel
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof SiriRideStopPydanticModel
     */
    'siri_stop_id': number;
    /**
     * 
     * @type {number}
     * @memberof SiriRideStopPydanticModel
     */
    'siri_ride_id': number;
    /**
     * 
     * @type {number}
     * @memberof SiriRideStopPydanticModel
     */
    'order': number;
    /**
     * 
     * @type {number}
     * @memberof SiriRideStopPydanticModel
     */
    'gtfs_stop_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof SiriRideStopPydanticModel
     */
    'nearest_siri_vehicle_location_id'?: number;
}
/**
 * 
 * @export
 * @interface SiriRideStopWithRelatedPydanticModel
 */
export interface SiriRideStopWithRelatedPydanticModel {
    /**
     * 
     * @type {number}
     * @memberof SiriRideStopWithRelatedPydanticModel
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof SiriRideStopWithRelatedPydanticModel
     */
    'siri_stop_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof SiriRideStopWithRelatedPydanticModel
     */
    'siri_ride_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof SiriRideStopWithRelatedPydanticModel
     */
    'order'?: number;
    /**
     * 
     * @type {number}
     * @memberof SiriRideStopWithRelatedPydanticModel
     */
    'gtfs_stop_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof SiriRideStopWithRelatedPydanticModel
     */
    'nearest_siri_vehicle_location_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof SiriRideStopWithRelatedPydanticModel
     */
    'siri_stop__code'?: number;
    /**
     * 
     * @type {number}
     * @memberof SiriRideStopWithRelatedPydanticModel
     */
    'siri_ride__siri_route_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof SiriRideStopWithRelatedPydanticModel
     */
    'siri_ride__journey_ref'?: string;
    /**
     * 
     * @type {string}
     * @memberof SiriRideStopWithRelatedPydanticModel
     */
    'siri_ride__scheduled_start_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof SiriRideStopWithRelatedPydanticModel
     */
    'siri_ride__vehicle_ref'?: string;
    /**
     * 
     * @type {string}
     * @memberof SiriRideStopWithRelatedPydanticModel
     */
    'siri_ride__updated_first_last_vehicle_locations'?: string;
    /**
     * 
     * @type {number}
     * @memberof SiriRideStopWithRelatedPydanticModel
     */
    'siri_ride__first_vehicle_location_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof SiriRideStopWithRelatedPydanticModel
     */
    'siri_ride__last_vehicle_location_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof SiriRideStopWithRelatedPydanticModel
     */
    'siri_ride__updated_duration_minutes'?: string;
    /**
     * 
     * @type {number}
     * @memberof SiriRideStopWithRelatedPydanticModel
     */
    'siri_ride__duration_minutes'?: number;
    /**
     * 
     * @type {number}
     * @memberof SiriRideStopWithRelatedPydanticModel
     */
    'siri_ride__journey_gtfs_ride_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof SiriRideStopWithRelatedPydanticModel
     */
    'siri_ride__route_gtfs_ride_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof SiriRideStopWithRelatedPydanticModel
     */
    'siri_ride__gtfs_ride_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof SiriRideStopWithRelatedPydanticModel
     */
    'gtfs_stop__date'?: string;
    /**
     * 
     * @type {number}
     * @memberof SiriRideStopWithRelatedPydanticModel
     */
    'gtfs_stop__code'?: number;
    /**
     * 
     * @type {number}
     * @memberof SiriRideStopWithRelatedPydanticModel
     */
    'gtfs_stop__lat'?: number;
    /**
     * 
     * @type {number}
     * @memberof SiriRideStopWithRelatedPydanticModel
     */
    'gtfs_stop__lon'?: number;
    /**
     * 
     * @type {string}
     * @memberof SiriRideStopWithRelatedPydanticModel
     */
    'gtfs_stop__name'?: string;
    /**
     * 
     * @type {string}
     * @memberof SiriRideStopWithRelatedPydanticModel
     */
    'gtfs_stop__city'?: string;
    /**
     * 
     * @type {number}
     * @memberof SiriRideStopWithRelatedPydanticModel
     */
    'nearest_siri_vehicle_location__siri_snapshot_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof SiriRideStopWithRelatedPydanticModel
     */
    'nearest_siri_vehicle_location__siri_ride_stop_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof SiriRideStopWithRelatedPydanticModel
     */
    'nearest_siri_vehicle_location__recorded_at_time'?: string;
    /**
     * 
     * @type {number}
     * @memberof SiriRideStopWithRelatedPydanticModel
     */
    'nearest_siri_vehicle_location__lon'?: number;
    /**
     * 
     * @type {number}
     * @memberof SiriRideStopWithRelatedPydanticModel
     */
    'nearest_siri_vehicle_location__lat'?: number;
    /**
     * 
     * @type {number}
     * @memberof SiriRideStopWithRelatedPydanticModel
     */
    'nearest_siri_vehicle_location__bearing'?: number;
    /**
     * 
     * @type {number}
     * @memberof SiriRideStopWithRelatedPydanticModel
     */
    'nearest_siri_vehicle_location__velocity'?: number;
    /**
     * 
     * @type {number}
     * @memberof SiriRideStopWithRelatedPydanticModel
     */
    'nearest_siri_vehicle_location__distance_from_journey_start'?: number;
    /**
     * 
     * @type {number}
     * @memberof SiriRideStopWithRelatedPydanticModel
     */
    'nearest_siri_vehicle_location__distance_from_siri_ride_stop_meters'?: number;
    /**
     * 
     * @type {number}
     * @memberof SiriRideStopWithRelatedPydanticModel
     */
    'gtfs_ride_stop__gtfs_stop_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof SiriRideStopWithRelatedPydanticModel
     */
    'gtfs_ride_stop__gtfs_ride_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof SiriRideStopWithRelatedPydanticModel
     */
    'gtfs_ride_stop__arrival_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof SiriRideStopWithRelatedPydanticModel
     */
    'gtfs_ride_stop__departure_time'?: string;
    /**
     * 
     * @type {number}
     * @memberof SiriRideStopWithRelatedPydanticModel
     */
    'gtfs_ride_stop__stop_sequence'?: number;
    /**
     * 
     * @type {number}
     * @memberof SiriRideStopWithRelatedPydanticModel
     */
    'gtfs_ride_stop__pickup_type'?: number;
    /**
     * 
     * @type {number}
     * @memberof SiriRideStopWithRelatedPydanticModel
     */
    'gtfs_ride_stop__drop_off_type'?: number;
    /**
     * 
     * @type {number}
     * @memberof SiriRideStopWithRelatedPydanticModel
     */
    'gtfs_ride_stop__shape_dist_traveled'?: number;
    /**
     * 
     * @type {number}
     * @memberof SiriRideStopWithRelatedPydanticModel
     */
    'gtfs_ride__gtfs_route_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof SiriRideStopWithRelatedPydanticModel
     */
    'gtfs_ride__journey_ref'?: string;
    /**
     * 
     * @type {string}
     * @memberof SiriRideStopWithRelatedPydanticModel
     */
    'gtfs_ride__start_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof SiriRideStopWithRelatedPydanticModel
     */
    'gtfs_ride__end_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof SiriRideStopWithRelatedPydanticModel
     */
    'gtfs_route__date'?: string;
    /**
     * 
     * @type {number}
     * @memberof SiriRideStopWithRelatedPydanticModel
     */
    'gtfs_route__line_ref'?: number;
    /**
     * 
     * @type {number}
     * @memberof SiriRideStopWithRelatedPydanticModel
     */
    'gtfs_route__operator_ref'?: number;
    /**
     * 
     * @type {string}
     * @memberof SiriRideStopWithRelatedPydanticModel
     */
    'gtfs_route__route_short_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof SiriRideStopWithRelatedPydanticModel
     */
    'gtfs_route__route_long_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof SiriRideStopWithRelatedPydanticModel
     */
    'gtfs_route__route_mkt'?: string;
    /**
     * 
     * @type {string}
     * @memberof SiriRideStopWithRelatedPydanticModel
     */
    'gtfs_route__route_direction'?: string;
    /**
     * 
     * @type {string}
     * @memberof SiriRideStopWithRelatedPydanticModel
     */
    'gtfs_route__route_alternative'?: string;
    /**
     * 
     * @type {string}
     * @memberof SiriRideStopWithRelatedPydanticModel
     */
    'gtfs_route__agency_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof SiriRideStopWithRelatedPydanticModel
     */
    'gtfs_route__route_type'?: string;
}
/**
 * 
 * @export
 * @interface SiriRideWithRelatedPydanticModel
 */
export interface SiriRideWithRelatedPydanticModel {
    /**
     * 
     * @type {number}
     * @memberof SiriRideWithRelatedPydanticModel
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof SiriRideWithRelatedPydanticModel
     */
    'siri_route_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof SiriRideWithRelatedPydanticModel
     */
    'journey_ref'?: string;
    /**
     * 
     * @type {string}
     * @memberof SiriRideWithRelatedPydanticModel
     */
    'scheduled_start_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof SiriRideWithRelatedPydanticModel
     */
    'vehicle_ref'?: string;
    /**
     * 
     * @type {string}
     * @memberof SiriRideWithRelatedPydanticModel
     */
    'updated_first_last_vehicle_locations'?: string;
    /**
     * 
     * @type {number}
     * @memberof SiriRideWithRelatedPydanticModel
     */
    'first_vehicle_location_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof SiriRideWithRelatedPydanticModel
     */
    'last_vehicle_location_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof SiriRideWithRelatedPydanticModel
     */
    'updated_duration_minutes'?: string;
    /**
     * 
     * @type {number}
     * @memberof SiriRideWithRelatedPydanticModel
     */
    'duration_minutes'?: number;
    /**
     * 
     * @type {number}
     * @memberof SiriRideWithRelatedPydanticModel
     */
    'journey_gtfs_ride_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof SiriRideWithRelatedPydanticModel
     */
    'route_gtfs_ride_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof SiriRideWithRelatedPydanticModel
     */
    'gtfs_ride_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof SiriRideWithRelatedPydanticModel
     */
    'siri_route__line_ref'?: number;
    /**
     * 
     * @type {number}
     * @memberof SiriRideWithRelatedPydanticModel
     */
    'siri_route__operator_ref'?: number;
    /**
     * 
     * @type {number}
     * @memberof SiriRideWithRelatedPydanticModel
     */
    'gtfs_ride__gtfs_route_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof SiriRideWithRelatedPydanticModel
     */
    'gtfs_ride__journey_ref'?: string;
    /**
     * 
     * @type {string}
     * @memberof SiriRideWithRelatedPydanticModel
     */
    'gtfs_ride__start_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof SiriRideWithRelatedPydanticModel
     */
    'gtfs_ride__end_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof SiriRideWithRelatedPydanticModel
     */
    'gtfs_route__date'?: string;
    /**
     * 
     * @type {number}
     * @memberof SiriRideWithRelatedPydanticModel
     */
    'gtfs_route__line_ref'?: number;
    /**
     * 
     * @type {number}
     * @memberof SiriRideWithRelatedPydanticModel
     */
    'gtfs_route__operator_ref'?: number;
    /**
     * 
     * @type {string}
     * @memberof SiriRideWithRelatedPydanticModel
     */
    'gtfs_route__route_short_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof SiriRideWithRelatedPydanticModel
     */
    'gtfs_route__route_long_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof SiriRideWithRelatedPydanticModel
     */
    'gtfs_route__route_mkt'?: string;
    /**
     * 
     * @type {string}
     * @memberof SiriRideWithRelatedPydanticModel
     */
    'gtfs_route__route_direction'?: string;
    /**
     * 
     * @type {string}
     * @memberof SiriRideWithRelatedPydanticModel
     */
    'gtfs_route__route_alternative'?: string;
    /**
     * 
     * @type {string}
     * @memberof SiriRideWithRelatedPydanticModel
     */
    'gtfs_route__agency_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof SiriRideWithRelatedPydanticModel
     */
    'gtfs_route__route_type'?: string;
}
/**
 * 
 * @export
 * @interface SiriRoutePydanticModel
 */
export interface SiriRoutePydanticModel {
    /**
     * 
     * @type {number}
     * @memberof SiriRoutePydanticModel
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof SiriRoutePydanticModel
     */
    'line_ref': number;
    /**
     * 
     * @type {number}
     * @memberof SiriRoutePydanticModel
     */
    'operator_ref': number;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const SiriSnapshotEtlStatusEnum = {
    Pending: 'pending',
    Loading: 'loading',
    Loaded: 'loaded',
    Error: 'error',
    Deleted: 'deleted'
} as const;

export type SiriSnapshotEtlStatusEnum = typeof SiriSnapshotEtlStatusEnum[keyof typeof SiriSnapshotEtlStatusEnum];


/**
 * 
 * @export
 * @interface SiriSnapshotPydanticModel
 */
export interface SiriSnapshotPydanticModel {
    /**
     * 
     * @type {number}
     * @memberof SiriSnapshotPydanticModel
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof SiriSnapshotPydanticModel
     */
    'snapshot_id': string;
    /**
     * 
     * @type {SiriSnapshotEtlStatusEnum}
     * @memberof SiriSnapshotPydanticModel
     */
    'etl_status': SiriSnapshotEtlStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof SiriSnapshotPydanticModel
     */
    'etl_start_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof SiriSnapshotPydanticModel
     */
    'etl_end_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof SiriSnapshotPydanticModel
     */
    'error'?: string;
    /**
     * 
     * @type {number}
     * @memberof SiriSnapshotPydanticModel
     */
    'num_successful_parse_vehicle_locations'?: number;
    /**
     * 
     * @type {number}
     * @memberof SiriSnapshotPydanticModel
     */
    'num_failed_parse_vehicle_locations'?: number;
    /**
     * 
     * @type {number}
     * @memberof SiriSnapshotPydanticModel
     */
    'num_added_siri_rides'?: number;
    /**
     * 
     * @type {number}
     * @memberof SiriSnapshotPydanticModel
     */
    'num_added_siri_ride_stops'?: number;
    /**
     * 
     * @type {number}
     * @memberof SiriSnapshotPydanticModel
     */
    'num_added_siri_routes'?: number;
    /**
     * 
     * @type {number}
     * @memberof SiriSnapshotPydanticModel
     */
    'num_added_siri_stops'?: number;
    /**
     * 
     * @type {string}
     * @memberof SiriSnapshotPydanticModel
     */
    'last_heartbeat'?: string;
    /**
     * 
     * @type {string}
     * @memberof SiriSnapshotPydanticModel
     */
    'created_by'?: string;
}


/**
 * 
 * @export
 * @interface SiriStopPydanticModel
 */
export interface SiriStopPydanticModel {
    /**
     * 
     * @type {number}
     * @memberof SiriStopPydanticModel
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof SiriStopPydanticModel
     */
    'code': number;
}
/**
 * 
 * @export
 * @interface SiriVehicleLocationPydanticModel
 */
export interface SiriVehicleLocationPydanticModel {
    /**
     * 
     * @type {number}
     * @memberof SiriVehicleLocationPydanticModel
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof SiriVehicleLocationPydanticModel
     */
    'siri_snapshot_id': number;
    /**
     * 
     * @type {number}
     * @memberof SiriVehicleLocationPydanticModel
     */
    'siri_ride_stop_id': number;
    /**
     * 
     * @type {string}
     * @memberof SiriVehicleLocationPydanticModel
     */
    'recorded_at_time': string;
    /**
     * 
     * @type {number}
     * @memberof SiriVehicleLocationPydanticModel
     */
    'lon': number;
    /**
     * 
     * @type {number}
     * @memberof SiriVehicleLocationPydanticModel
     */
    'lat': number;
    /**
     * 
     * @type {number}
     * @memberof SiriVehicleLocationPydanticModel
     */
    'bearing': number;
    /**
     * 
     * @type {number}
     * @memberof SiriVehicleLocationPydanticModel
     */
    'velocity': number;
    /**
     * 
     * @type {number}
     * @memberof SiriVehicleLocationPydanticModel
     */
    'distance_from_journey_start': number;
    /**
     * 
     * @type {number}
     * @memberof SiriVehicleLocationPydanticModel
     */
    'distance_from_siri_ride_stop_meters'?: number;
}
/**
 * 
 * @export
 * @interface SiriVehicleLocationWithRelatedPydanticModel
 */
export interface SiriVehicleLocationWithRelatedPydanticModel {
    /**
     * 
     * @type {number}
     * @memberof SiriVehicleLocationWithRelatedPydanticModel
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof SiriVehicleLocationWithRelatedPydanticModel
     */
    'siri_snapshot_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof SiriVehicleLocationWithRelatedPydanticModel
     */
    'siri_ride_stop_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof SiriVehicleLocationWithRelatedPydanticModel
     */
    'recorded_at_time'?: string;
    /**
     * 
     * @type {number}
     * @memberof SiriVehicleLocationWithRelatedPydanticModel
     */
    'lon'?: number;
    /**
     * 
     * @type {number}
     * @memberof SiriVehicleLocationWithRelatedPydanticModel
     */
    'lat'?: number;
    /**
     * 
     * @type {number}
     * @memberof SiriVehicleLocationWithRelatedPydanticModel
     */
    'bearing'?: number;
    /**
     * 
     * @type {number}
     * @memberof SiriVehicleLocationWithRelatedPydanticModel
     */
    'velocity'?: number;
    /**
     * 
     * @type {number}
     * @memberof SiriVehicleLocationWithRelatedPydanticModel
     */
    'distance_from_journey_start'?: number;
    /**
     * 
     * @type {number}
     * @memberof SiriVehicleLocationWithRelatedPydanticModel
     */
    'distance_from_siri_ride_stop_meters'?: number;
    /**
     * 
     * @type {string}
     * @memberof SiriVehicleLocationWithRelatedPydanticModel
     */
    'siri_snapshot__snapshot_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof SiriVehicleLocationWithRelatedPydanticModel
     */
    'siri_route__id'?: number;
    /**
     * 
     * @type {number}
     * @memberof SiriVehicleLocationWithRelatedPydanticModel
     */
    'siri_route__line_ref'?: number;
    /**
     * 
     * @type {number}
     * @memberof SiriVehicleLocationWithRelatedPydanticModel
     */
    'siri_route__operator_ref'?: number;
    /**
     * 
     * @type {number}
     * @memberof SiriVehicleLocationWithRelatedPydanticModel
     */
    'siri_ride__id'?: number;
    /**
     * 
     * @type {string}
     * @memberof SiriVehicleLocationWithRelatedPydanticModel
     */
    'siri_ride__journey_ref'?: string;
    /**
     * 
     * @type {string}
     * @memberof SiriVehicleLocationWithRelatedPydanticModel
     */
    'siri_ride__scheduled_start_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof SiriVehicleLocationWithRelatedPydanticModel
     */
    'siri_ride__vehicle_ref'?: string;
    /**
     * 
     * @type {number}
     * @memberof SiriVehicleLocationWithRelatedPydanticModel
     */
    'siri_ride__first_vehicle_location_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof SiriVehicleLocationWithRelatedPydanticModel
     */
    'siri_ride__last_vehicle_location_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof SiriVehicleLocationWithRelatedPydanticModel
     */
    'siri_ride__duration_minutes'?: number;
    /**
     * 
     * @type {number}
     * @memberof SiriVehicleLocationWithRelatedPydanticModel
     */
    'siri_ride__gtfs_ride_id'?: number;
}
/**
 * 
 * @export
 * @interface StopArrivalPydanticModel
 */
export interface StopArrivalPydanticModel {
    /**
     * 
     * @type {string}
     * @memberof StopArrivalPydanticModel
     */
    'actual_arrival_time'?: string;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<LocationInner>}
     * @memberof ValidationError
     */
    'loc': Array<LocationInner>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'type': string;
}

/**
 * AggregationsApi - axios parameter creator
 * @export
 */
export const AggregationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * gtfs rides aggregation grouped by given fields.
         * @summary Group By 
         * @param {string} dateFrom   Filter by date. Only return items which have a date after or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
         * @param {string} dateTo   Filter by date. Only return items which have a date before or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
         * @param {string} groupBy Comma-separated list of fields to group by. Valid values: gtfs_route_date, gtfs_route_hour, operator_ref, day_of_week, line_ref.
         * @param {number} [excludeHoursFrom] Hours to exclude from search, currently used to filter out edge cases.  Filter by hour. Only return items which have an hour date after or equals to given value. Format: 0(12AM)-23
         * @param {number} [excludeHoursTo] Hours to exclude from search, currently used to filter out edge cases.  Filter by hour. Only return items which have a date before or equals to given value. Format: 0(12AM)-23
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupByGtfsRidesAggGroupByGet: async (dateFrom: string, dateTo: string, groupBy: string, excludeHoursFrom?: number, excludeHoursTo?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dateFrom' is not null or undefined
            assertParamExists('groupByGtfsRidesAggGroupByGet', 'dateFrom', dateFrom)
            // verify required parameter 'dateTo' is not null or undefined
            assertParamExists('groupByGtfsRidesAggGroupByGet', 'dateTo', dateTo)
            // verify required parameter 'groupBy' is not null or undefined
            assertParamExists('groupByGtfsRidesAggGroupByGet', 'groupBy', groupBy)
            const localVarPath = `/gtfs_rides_agg/group_by`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (dateFrom !== undefined) {
                localVarQueryParameter['date_from'] = (dateFrom as any instanceof Date) ?
                    (dateFrom as any).toISOString().substring(0,10) :
                    dateFrom;
            }

            if (dateTo !== undefined) {
                localVarQueryParameter['date_to'] = (dateTo as any instanceof Date) ?
                    (dateTo as any).toISOString().substring(0,10) :
                    dateTo;
            }

            if (excludeHoursFrom !== undefined) {
                localVarQueryParameter['exclude_hours_from'] = excludeHoursFrom;
            }

            if (excludeHoursTo !== undefined) {
                localVarQueryParameter['exclude_hours_to'] = excludeHoursTo;
            }

            if (groupBy !== undefined) {
                localVarQueryParameter['group_by'] = groupBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List of gtfs rides aggregations.
         * @summary List 
         * @param {string} dateFrom   Filter by date. Only return items which have a date after or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
         * @param {string} dateTo   Filter by date. Only return items which have a date before or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
         * @param {number} [limit] Limit the number of returned results. If not specified will limit to 1000 results. To get more results, you can either use the offset param, alternatively - set the limit to -1 and use http streaming with compatible json streaming decoder to get all results, this method can fetch up to a maximum of 500000 results.
         * @param {number} [offset] Item number to start returning results from. Use in combination with limit for pagination, alternatively, don\&#39;t set offset, set limit to -1 and use http streaming with compatible json streaming decoder to get all results up to a maximum of 500000 results.
         * @param {boolean} [getCount] Set to \&quot;true\&quot; to only get the total number of results for given filters. limit/offset/order parameters will be ignored.
         * @param {number} [excludeHoursFrom] Hours to exclude from search, currently used to filter out edge cases.  Filter by hour. Only return items which have an hour date after or equals to given value. Format: 0(12AM)-23
         * @param {number} [excludeHoursTo] Hours to exclude from search, currently used to filter out edge cases.  Filter by hour. Only return items which have a date before or equals to given value. Format: 0(12AM)-23
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGtfsRidesAggListGet: async (dateFrom: string, dateTo: string, limit?: number, offset?: number, getCount?: boolean, excludeHoursFrom?: number, excludeHoursTo?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dateFrom' is not null or undefined
            assertParamExists('listGtfsRidesAggListGet', 'dateFrom', dateFrom)
            // verify required parameter 'dateTo' is not null or undefined
            assertParamExists('listGtfsRidesAggListGet', 'dateTo', dateTo)
            const localVarPath = `/gtfs_rides_agg/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (getCount !== undefined) {
                localVarQueryParameter['get_count'] = getCount;
            }

            if (dateFrom !== undefined) {
                localVarQueryParameter['date_from'] = (dateFrom as any instanceof Date) ?
                    (dateFrom as any).toISOString().substring(0,10) :
                    dateFrom;
            }

            if (dateTo !== undefined) {
                localVarQueryParameter['date_to'] = (dateTo as any instanceof Date) ?
                    (dateTo as any).toISOString().substring(0,10) :
                    dateTo;
            }

            if (excludeHoursFrom !== undefined) {
                localVarQueryParameter['exclude_hours_from'] = excludeHoursFrom;
            }

            if (excludeHoursTo !== undefined) {
                localVarQueryParameter['exclude_hours_to'] = excludeHoursTo;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AggregationsApi - functional programming interface
 * @export
 */
export const AggregationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AggregationsApiAxiosParamCreator(configuration)
    return {
        /**
         * gtfs rides aggregation grouped by given fields.
         * @summary Group By 
         * @param {string} dateFrom   Filter by date. Only return items which have a date after or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
         * @param {string} dateTo   Filter by date. Only return items which have a date before or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
         * @param {string} groupBy Comma-separated list of fields to group by. Valid values: gtfs_route_date, gtfs_route_hour, operator_ref, day_of_week, line_ref.
         * @param {number} [excludeHoursFrom] Hours to exclude from search, currently used to filter out edge cases.  Filter by hour. Only return items which have an hour date after or equals to given value. Format: 0(12AM)-23
         * @param {number} [excludeHoursTo] Hours to exclude from search, currently used to filter out edge cases.  Filter by hour. Only return items which have a date before or equals to given value. Format: 0(12AM)-23
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupByGtfsRidesAggGroupByGet(dateFrom: string, dateTo: string, groupBy: string, excludeHoursFrom?: number, excludeHoursTo?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GtfsRidesAggGroupByPydanticModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupByGtfsRidesAggGroupByGet(dateFrom, dateTo, groupBy, excludeHoursFrom, excludeHoursTo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AggregationsApi.groupByGtfsRidesAggGroupByGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List of gtfs rides aggregations.
         * @summary List 
         * @param {string} dateFrom   Filter by date. Only return items which have a date after or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
         * @param {string} dateTo   Filter by date. Only return items which have a date before or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
         * @param {number} [limit] Limit the number of returned results. If not specified will limit to 1000 results. To get more results, you can either use the offset param, alternatively - set the limit to -1 and use http streaming with compatible json streaming decoder to get all results, this method can fetch up to a maximum of 500000 results.
         * @param {number} [offset] Item number to start returning results from. Use in combination with limit for pagination, alternatively, don\&#39;t set offset, set limit to -1 and use http streaming with compatible json streaming decoder to get all results up to a maximum of 500000 results.
         * @param {boolean} [getCount] Set to \&quot;true\&quot; to only get the total number of results for given filters. limit/offset/order parameters will be ignored.
         * @param {number} [excludeHoursFrom] Hours to exclude from search, currently used to filter out edge cases.  Filter by hour. Only return items which have an hour date after or equals to given value. Format: 0(12AM)-23
         * @param {number} [excludeHoursTo] Hours to exclude from search, currently used to filter out edge cases.  Filter by hour. Only return items which have a date before or equals to given value. Format: 0(12AM)-23
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGtfsRidesAggListGet(dateFrom: string, dateTo: string, limit?: number, offset?: number, getCount?: boolean, excludeHoursFrom?: number, excludeHoursTo?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GtfsRidesAggPydanticModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGtfsRidesAggListGet(dateFrom, dateTo, limit, offset, getCount, excludeHoursFrom, excludeHoursTo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AggregationsApi.listGtfsRidesAggListGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AggregationsApi - factory interface
 * @export
 */
export const AggregationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AggregationsApiFp(configuration)
    return {
        /**
         * gtfs rides aggregation grouped by given fields.
         * @summary Group By 
         * @param {string} dateFrom   Filter by date. Only return items which have a date after or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
         * @param {string} dateTo   Filter by date. Only return items which have a date before or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
         * @param {string} groupBy Comma-separated list of fields to group by. Valid values: gtfs_route_date, gtfs_route_hour, operator_ref, day_of_week, line_ref.
         * @param {number} [excludeHoursFrom] Hours to exclude from search, currently used to filter out edge cases.  Filter by hour. Only return items which have an hour date after or equals to given value. Format: 0(12AM)-23
         * @param {number} [excludeHoursTo] Hours to exclude from search, currently used to filter out edge cases.  Filter by hour. Only return items which have a date before or equals to given value. Format: 0(12AM)-23
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupByGtfsRidesAggGroupByGet(dateFrom: string, dateTo: string, groupBy: string, excludeHoursFrom?: number, excludeHoursTo?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<GtfsRidesAggGroupByPydanticModel>> {
            return localVarFp.groupByGtfsRidesAggGroupByGet(dateFrom, dateTo, groupBy, excludeHoursFrom, excludeHoursTo, options).then((request) => request(axios, basePath));
        },
        /**
         * List of gtfs rides aggregations.
         * @summary List 
         * @param {string} dateFrom   Filter by date. Only return items which have a date after or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
         * @param {string} dateTo   Filter by date. Only return items which have a date before or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
         * @param {number} [limit] Limit the number of returned results. If not specified will limit to 1000 results. To get more results, you can either use the offset param, alternatively - set the limit to -1 and use http streaming with compatible json streaming decoder to get all results, this method can fetch up to a maximum of 500000 results.
         * @param {number} [offset] Item number to start returning results from. Use in combination with limit for pagination, alternatively, don\&#39;t set offset, set limit to -1 and use http streaming with compatible json streaming decoder to get all results up to a maximum of 500000 results.
         * @param {boolean} [getCount] Set to \&quot;true\&quot; to only get the total number of results for given filters. limit/offset/order parameters will be ignored.
         * @param {number} [excludeHoursFrom] Hours to exclude from search, currently used to filter out edge cases.  Filter by hour. Only return items which have an hour date after or equals to given value. Format: 0(12AM)-23
         * @param {number} [excludeHoursTo] Hours to exclude from search, currently used to filter out edge cases.  Filter by hour. Only return items which have a date before or equals to given value. Format: 0(12AM)-23
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGtfsRidesAggListGet(dateFrom: string, dateTo: string, limit?: number, offset?: number, getCount?: boolean, excludeHoursFrom?: number, excludeHoursTo?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<GtfsRidesAggPydanticModel>> {
            return localVarFp.listGtfsRidesAggListGet(dateFrom, dateTo, limit, offset, getCount, excludeHoursFrom, excludeHoursTo, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AggregationsApi - object-oriented interface
 * @export
 * @class AggregationsApi
 * @extends {BaseAPI}
 */
export class AggregationsApi extends BaseAPI {
    /**
     * gtfs rides aggregation grouped by given fields.
     * @summary Group By 
     * @param {string} dateFrom   Filter by date. Only return items which have a date after or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
     * @param {string} dateTo   Filter by date. Only return items which have a date before or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
     * @param {string} groupBy Comma-separated list of fields to group by. Valid values: gtfs_route_date, gtfs_route_hour, operator_ref, day_of_week, line_ref.
     * @param {number} [excludeHoursFrom] Hours to exclude from search, currently used to filter out edge cases.  Filter by hour. Only return items which have an hour date after or equals to given value. Format: 0(12AM)-23
     * @param {number} [excludeHoursTo] Hours to exclude from search, currently used to filter out edge cases.  Filter by hour. Only return items which have a date before or equals to given value. Format: 0(12AM)-23
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AggregationsApi
     */
    public groupByGtfsRidesAggGroupByGet(dateFrom: string, dateTo: string, groupBy: string, excludeHoursFrom?: number, excludeHoursTo?: number, options?: RawAxiosRequestConfig) {
        return AggregationsApiFp(this.configuration).groupByGtfsRidesAggGroupByGet(dateFrom, dateTo, groupBy, excludeHoursFrom, excludeHoursTo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List of gtfs rides aggregations.
     * @summary List 
     * @param {string} dateFrom   Filter by date. Only return items which have a date after or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
     * @param {string} dateTo   Filter by date. Only return items which have a date before or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
     * @param {number} [limit] Limit the number of returned results. If not specified will limit to 1000 results. To get more results, you can either use the offset param, alternatively - set the limit to -1 and use http streaming with compatible json streaming decoder to get all results, this method can fetch up to a maximum of 500000 results.
     * @param {number} [offset] Item number to start returning results from. Use in combination with limit for pagination, alternatively, don\&#39;t set offset, set limit to -1 and use http streaming with compatible json streaming decoder to get all results up to a maximum of 500000 results.
     * @param {boolean} [getCount] Set to \&quot;true\&quot; to only get the total number of results for given filters. limit/offset/order parameters will be ignored.
     * @param {number} [excludeHoursFrom] Hours to exclude from search, currently used to filter out edge cases.  Filter by hour. Only return items which have an hour date after or equals to given value. Format: 0(12AM)-23
     * @param {number} [excludeHoursTo] Hours to exclude from search, currently used to filter out edge cases.  Filter by hour. Only return items which have a date before or equals to given value. Format: 0(12AM)-23
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AggregationsApi
     */
    public listGtfsRidesAggListGet(dateFrom: string, dateTo: string, limit?: number, offset?: number, getCount?: boolean, excludeHoursFrom?: number, excludeHoursTo?: number, options?: RawAxiosRequestConfig) {
        return AggregationsApiFp(this.configuration).listGtfsRidesAggListGet(dateFrom, dateTo, limit, offset, getCount, excludeHoursFrom, excludeHoursTo, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GtfsApi - axios parameter creator
 * @export
 */
export const GtfsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Return a single gtfs ride stop based on id
         * @summary Get 
         * @param {number} id gtfs ride stop id to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGtfsRideStopsGetGet: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getGtfsRideStopsGetGet', 'id', id)
            const localVarPath = `/gtfs_ride_stops/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a single gtfs ride based on id
         * @summary Get 
         * @param {number} id gtfs ride id to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGtfsRidesGetGet: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getGtfsRidesGetGet', 'id', id)
            const localVarPath = `/gtfs_rides/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a single gtfs route based on id
         * @summary Get 
         * @param {number} id gtfs route id to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGtfsRoutesGetGet: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getGtfsRoutesGetGet', 'id', id)
            const localVarPath = `/gtfs_routes/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a single gtfs stop based on id
         * @summary Get 
         * @param {number} id gtfs stop id to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGtfsStopsGetGet: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getGtfsStopsGetGet', 'id', id)
            const localVarPath = `/gtfs_stops/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List of gtfs agencies.
         * @summary List 
         * @param {number} [limit] Limit the number of returned results. If not specified will limit to 100 results. To get more results, you can either use the offset param, alternatively - set the limit to -1 and use http streaming with compatible json streaming decoder to get all results, this method can fetch up to a maximum of 500000 results.
         * @param {number} [offset] Item number to start returning results from. Use in combination with limit for pagination, alternatively, don\&#39;t set offset, set limit to -1 and use http streaming with compatible json streaming decoder to get all results up to a maximum of 500000 results.
         * @param {string} [dateFrom]   Filter by date. Only return items which have a date after or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
         * @param {string} [dateTo]   Filter by date. Only return items which have a date before or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGtfsAgenciesListGet: async (limit?: number, offset?: number, dateFrom?: string, dateTo?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/gtfs_agencies/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (dateFrom !== undefined) {
                localVarQueryParameter['date_from'] = (dateFrom as any instanceof Date) ?
                    (dateFrom as any).toISOString().substring(0,10) :
                    dateFrom;
            }

            if (dateTo !== undefined) {
                localVarQueryParameter['date_to'] = (dateTo as any instanceof Date) ?
                    (dateTo as any).toISOString().substring(0,10) :
                    dateTo;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List of gtfs ride stops.  Due to large number of items in the table, you must filter the results by at least one of the following:  1. gtfs_ride_ids - containing a single gtfs ride id. 2. arrival_time_from and arrival_time_to - containing a time range.  Additional filters can be applied in addition to one of the above options to narrow down the results.
         * @summary List 
         * @param {number} [limit] Limit the number of returned results. If not specified will limit to 100 results. To get more results, you can either use the offset param, alternatively - set the limit to -1 and use http streaming with compatible json streaming decoder to get all results, this method can fetch up to a maximum of 500000 results.
         * @param {number} [offset] Item number to start returning results from. Use in combination with limit for pagination, alternatively, don\&#39;t set offset, set limit to -1 and use http streaming with compatible json streaming decoder to get all results up to a maximum of 500000 results.
         * @param {boolean} [getCount] Set to \&quot;true\&quot; to only get the total number of results for given filters. limit/offset/order parameters will be ignored.
         * @param {string} [arrivalTimeFrom]   Filter by arrival time from. Only return items which have date/time after or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
         * @param {string} [arrivalTimeTo]   Filter by arrival time to. Only return items which have date/time before or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
         * @param {string} [gtfsStopIds]   Filter by gtfs stop id. Comma-separated list of values.
         * @param {string} [gtfsRideIds]   Filter by gtfs ride id. Comma-separated list of values.
         * @param {number} [gtfsRideGtfsRouteId]   Filter by related gtfs ride\&#39;s gtfs route id. Only return items which exactly match given string.
         * @param {string} [gtfsRideJourneyRefPrefix]   Filter by related gtfs ride\&#39;s journey ref prefix. Only return items which start with given string.
         * @param {string} [gtfsRideStartTimeFrom]   Filter by related gtfs ride\&#39;s start time from. Only return items which have date/time after or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
         * @param {string} [gtfsRideStartTimeTo]   Filter by related gtfs ride\&#39;s start time to. Only return items which have date/time before or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
         * @param {string} [gtfsStopDateFrom]   Filter by related gtfs stop\&#39;s date. Only return items which have a date after or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
         * @param {string} [gtfsStopDateTo]   Filter by related gtfs stop\&#39;s date. Only return items which have a date before or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
         * @param {number} [gtfsStopCode]   Filter by related gtfs stop\&#39;s code. Only return items which exactly match given string.
         * @param {string} [gtfsStopCity]   Filter by related gtfs stop\&#39;s city. Only return items which exactly match given string.
         * @param {string} [gtfsRouteDateFrom]   Filter by related gtfs route\&#39;s date. Only return items which have a date after or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
         * @param {string} [gtfsRouteDateTo]   Filter by related gtfs route\&#39;s date. Only return items which have a date before or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
         * @param {string} [gtfsRouteLineRefs]   Filter by related gtfs route\&#39;s line ref. Comma-separated list of values.
         * @param {string} [gtfsRouteOperatorRefs] Agency identifier. To get it, first query gtfs_agencies.  Filter by related gtfs route\&#39;s operator ref. Comma-separated list of values.  Example: 3 for Eged
         * @param {string} [gtfsRouteRouteShortName] Line number.  Filter by related gtfs route\&#39;s route short name. Only return items which exactly match given string.  Example: 480
         * @param {string} [gtfsRouteRouteLongNameContains]   Filter by related gtfs route\&#39;s route long name. Only return items which contain given string.
         * @param {string} [gtfsRouteRouteMkt]   Filter by related gtfs route\&#39;s route mkt. Only return items which exactly match given string.
         * @param {string} [gtfsRouteRouteDirection]   Filter by related gtfs route\&#39;s route direction. Only return items which exactly match given string.
         * @param {string} [gtfsRouteRouteAlternative]   Filter by related gtfs route\&#39;s route alternative. Only return items which exactly match given string.
         * @param {string} [gtfsRouteAgencyName]   Filter by related gtfs route\&#39;s agency name. Only return items which exactly match given string.
         * @param {string} [gtfsRouteRouteType]   Filter by related gtfs route\&#39;s route type. Only return items which exactly match given string.
         * @param {string} [orderBy] Order of the results. Comma-separated list of fields and direction. e.g. \&quot;field1 asc,field2 desc\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGtfsRideStopsListGet: async (limit?: number, offset?: number, getCount?: boolean, arrivalTimeFrom?: string, arrivalTimeTo?: string, gtfsStopIds?: string, gtfsRideIds?: string, gtfsRideGtfsRouteId?: number, gtfsRideJourneyRefPrefix?: string, gtfsRideStartTimeFrom?: string, gtfsRideStartTimeTo?: string, gtfsStopDateFrom?: string, gtfsStopDateTo?: string, gtfsStopCode?: number, gtfsStopCity?: string, gtfsRouteDateFrom?: string, gtfsRouteDateTo?: string, gtfsRouteLineRefs?: string, gtfsRouteOperatorRefs?: string, gtfsRouteRouteShortName?: string, gtfsRouteRouteLongNameContains?: string, gtfsRouteRouteMkt?: string, gtfsRouteRouteDirection?: string, gtfsRouteRouteAlternative?: string, gtfsRouteAgencyName?: string, gtfsRouteRouteType?: string, orderBy?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/gtfs_ride_stops/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (getCount !== undefined) {
                localVarQueryParameter['get_count'] = getCount;
            }

            if (arrivalTimeFrom !== undefined) {
                localVarQueryParameter['arrival_time_from'] = (arrivalTimeFrom as any instanceof Date) ?
                    (arrivalTimeFrom as any).toISOString() :
                    arrivalTimeFrom;
            }

            if (arrivalTimeTo !== undefined) {
                localVarQueryParameter['arrival_time_to'] = (arrivalTimeTo as any instanceof Date) ?
                    (arrivalTimeTo as any).toISOString() :
                    arrivalTimeTo;
            }

            if (gtfsStopIds !== undefined) {
                localVarQueryParameter['gtfs_stop_ids'] = gtfsStopIds;
            }

            if (gtfsRideIds !== undefined) {
                localVarQueryParameter['gtfs_ride_ids'] = gtfsRideIds;
            }

            if (gtfsRideGtfsRouteId !== undefined) {
                localVarQueryParameter['gtfs_ride__gtfs_route_id'] = gtfsRideGtfsRouteId;
            }

            if (gtfsRideJourneyRefPrefix !== undefined) {
                localVarQueryParameter['gtfs_ride__journey_ref_prefix'] = gtfsRideJourneyRefPrefix;
            }

            if (gtfsRideStartTimeFrom !== undefined) {
                localVarQueryParameter['gtfs_ride__start_time_from'] = (gtfsRideStartTimeFrom as any instanceof Date) ?
                    (gtfsRideStartTimeFrom as any).toISOString() :
                    gtfsRideStartTimeFrom;
            }

            if (gtfsRideStartTimeTo !== undefined) {
                localVarQueryParameter['gtfs_ride__start_time_to'] = (gtfsRideStartTimeTo as any instanceof Date) ?
                    (gtfsRideStartTimeTo as any).toISOString() :
                    gtfsRideStartTimeTo;
            }

            if (gtfsStopDateFrom !== undefined) {
                localVarQueryParameter['gtfs_stop__date_from'] = (gtfsStopDateFrom as any instanceof Date) ?
                    (gtfsStopDateFrom as any).toISOString().substring(0,10) :
                    gtfsStopDateFrom;
            }

            if (gtfsStopDateTo !== undefined) {
                localVarQueryParameter['gtfs_stop__date_to'] = (gtfsStopDateTo as any instanceof Date) ?
                    (gtfsStopDateTo as any).toISOString().substring(0,10) :
                    gtfsStopDateTo;
            }

            if (gtfsStopCode !== undefined) {
                localVarQueryParameter['gtfs_stop__code'] = gtfsStopCode;
            }

            if (gtfsStopCity !== undefined) {
                localVarQueryParameter['gtfs_stop__city'] = gtfsStopCity;
            }

            if (gtfsRouteDateFrom !== undefined) {
                localVarQueryParameter['gtfs_route__date_from'] = (gtfsRouteDateFrom as any instanceof Date) ?
                    (gtfsRouteDateFrom as any).toISOString().substring(0,10) :
                    gtfsRouteDateFrom;
            }

            if (gtfsRouteDateTo !== undefined) {
                localVarQueryParameter['gtfs_route__date_to'] = (gtfsRouteDateTo as any instanceof Date) ?
                    (gtfsRouteDateTo as any).toISOString().substring(0,10) :
                    gtfsRouteDateTo;
            }

            if (gtfsRouteLineRefs !== undefined) {
                localVarQueryParameter['gtfs_route__line_refs'] = gtfsRouteLineRefs;
            }

            if (gtfsRouteOperatorRefs !== undefined) {
                localVarQueryParameter['gtfs_route__operator_refs'] = gtfsRouteOperatorRefs;
            }

            if (gtfsRouteRouteShortName !== undefined) {
                localVarQueryParameter['gtfs_route__route_short_name'] = gtfsRouteRouteShortName;
            }

            if (gtfsRouteRouteLongNameContains !== undefined) {
                localVarQueryParameter['gtfs_route__route_long_name_contains'] = gtfsRouteRouteLongNameContains;
            }

            if (gtfsRouteRouteMkt !== undefined) {
                localVarQueryParameter['gtfs_route__route_mkt'] = gtfsRouteRouteMkt;
            }

            if (gtfsRouteRouteDirection !== undefined) {
                localVarQueryParameter['gtfs_route__route_direction'] = gtfsRouteRouteDirection;
            }

            if (gtfsRouteRouteAlternative !== undefined) {
                localVarQueryParameter['gtfs_route__route_alternative'] = gtfsRouteRouteAlternative;
            }

            if (gtfsRouteAgencyName !== undefined) {
                localVarQueryParameter['gtfs_route__agency_name'] = gtfsRouteAgencyName;
            }

            if (gtfsRouteRouteType !== undefined) {
                localVarQueryParameter['gtfs_route__route_type'] = gtfsRouteRouteType;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List of gtfs rides.
         * @summary List 
         * @param {number} [limit] Limit the number of returned results. If not specified will limit to 100 results. To get more results, you can either use the offset param, alternatively - set the limit to -1 and use http streaming with compatible json streaming decoder to get all results, this method can fetch up to a maximum of 500000 results.
         * @param {number} [offset] Item number to start returning results from. Use in combination with limit for pagination, alternatively, don\&#39;t set offset, set limit to -1 and use http streaming with compatible json streaming decoder to get all results up to a maximum of 500000 results.
         * @param {boolean} [getCount] Set to \&quot;true\&quot; to only get the total number of results for given filters. limit/offset/order parameters will be ignored.
         * @param {number} [gtfsRouteId]   Filter by gtfs route id. Only return items which exactly match given string.
         * @param {string} [journeyRefPrefix]   Filter by journey ref prefix. Only return items which start with given string.
         * @param {string} [startTimeFrom]   Filter by start time from. Only return items which have date/time after or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
         * @param {string} [startTimeTo]   Filter by start time to. Only return items which have date/time before or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
         * @param {string} [gtfsRouteDateFrom]   Filter by related gtfs route\&#39;s date. Only return items which have a date after or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
         * @param {string} [gtfsRouteDateTo]   Filter by related gtfs route\&#39;s date. Only return items which have a date before or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
         * @param {string} [gtfsRouteLineRefs]   Filter by related gtfs route\&#39;s line ref. Comma-separated list of values.
         * @param {string} [gtfsRouteOperatorRefs] Agency identifier. To get it, first query gtfs_agencies.  Filter by related gtfs route\&#39;s operator ref. Comma-separated list of values.  Example: 3 for Eged
         * @param {string} [gtfsRouteRouteShortName] Line number.  Filter by related gtfs route\&#39;s route short name. Only return items which exactly match given string.  Example: 480
         * @param {string} [gtfsRouteRouteLongNameContains]   Filter by related gtfs route\&#39;s route long name. Only return items which contain given string.
         * @param {string} [gtfsRouteRouteMkt]   Filter by related gtfs route\&#39;s route mkt. Only return items which exactly match given string.
         * @param {string} [gtfsRouteRouteDirection]   Filter by related gtfs route\&#39;s route direction. Only return items which exactly match given string.
         * @param {string} [gtfsRouteRouteAlternative]   Filter by related gtfs route\&#39;s route alternative. Only return items which exactly match given string.
         * @param {string} [gtfsRouteAgencyName]   Filter by related gtfs route\&#39;s agency name. Only return items which exactly match given string.
         * @param {string} [gtfsRouteRouteType]   Filter by related gtfs route\&#39;s route type. Only return items which exactly match given string.
         * @param {string} [orderBy] Order of the results. Comma-separated list of fields and direction. e.g. \&quot;field1 asc,field2 desc\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGtfsRidesListGet: async (limit?: number, offset?: number, getCount?: boolean, gtfsRouteId?: number, journeyRefPrefix?: string, startTimeFrom?: string, startTimeTo?: string, gtfsRouteDateFrom?: string, gtfsRouteDateTo?: string, gtfsRouteLineRefs?: string, gtfsRouteOperatorRefs?: string, gtfsRouteRouteShortName?: string, gtfsRouteRouteLongNameContains?: string, gtfsRouteRouteMkt?: string, gtfsRouteRouteDirection?: string, gtfsRouteRouteAlternative?: string, gtfsRouteAgencyName?: string, gtfsRouteRouteType?: string, orderBy?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/gtfs_rides/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (getCount !== undefined) {
                localVarQueryParameter['get_count'] = getCount;
            }

            if (gtfsRouteId !== undefined) {
                localVarQueryParameter['gtfs_route_id'] = gtfsRouteId;
            }

            if (journeyRefPrefix !== undefined) {
                localVarQueryParameter['journey_ref_prefix'] = journeyRefPrefix;
            }

            if (startTimeFrom !== undefined) {
                localVarQueryParameter['start_time_from'] = (startTimeFrom as any instanceof Date) ?
                    (startTimeFrom as any).toISOString() :
                    startTimeFrom;
            }

            if (startTimeTo !== undefined) {
                localVarQueryParameter['start_time_to'] = (startTimeTo as any instanceof Date) ?
                    (startTimeTo as any).toISOString() :
                    startTimeTo;
            }

            if (gtfsRouteDateFrom !== undefined) {
                localVarQueryParameter['gtfs_route__date_from'] = (gtfsRouteDateFrom as any instanceof Date) ?
                    (gtfsRouteDateFrom as any).toISOString().substring(0,10) :
                    gtfsRouteDateFrom;
            }

            if (gtfsRouteDateTo !== undefined) {
                localVarQueryParameter['gtfs_route__date_to'] = (gtfsRouteDateTo as any instanceof Date) ?
                    (gtfsRouteDateTo as any).toISOString().substring(0,10) :
                    gtfsRouteDateTo;
            }

            if (gtfsRouteLineRefs !== undefined) {
                localVarQueryParameter['gtfs_route__line_refs'] = gtfsRouteLineRefs;
            }

            if (gtfsRouteOperatorRefs !== undefined) {
                localVarQueryParameter['gtfs_route__operator_refs'] = gtfsRouteOperatorRefs;
            }

            if (gtfsRouteRouteShortName !== undefined) {
                localVarQueryParameter['gtfs_route__route_short_name'] = gtfsRouteRouteShortName;
            }

            if (gtfsRouteRouteLongNameContains !== undefined) {
                localVarQueryParameter['gtfs_route__route_long_name_contains'] = gtfsRouteRouteLongNameContains;
            }

            if (gtfsRouteRouteMkt !== undefined) {
                localVarQueryParameter['gtfs_route__route_mkt'] = gtfsRouteRouteMkt;
            }

            if (gtfsRouteRouteDirection !== undefined) {
                localVarQueryParameter['gtfs_route__route_direction'] = gtfsRouteRouteDirection;
            }

            if (gtfsRouteRouteAlternative !== undefined) {
                localVarQueryParameter['gtfs_route__route_alternative'] = gtfsRouteRouteAlternative;
            }

            if (gtfsRouteAgencyName !== undefined) {
                localVarQueryParameter['gtfs_route__agency_name'] = gtfsRouteAgencyName;
            }

            if (gtfsRouteRouteType !== undefined) {
                localVarQueryParameter['gtfs_route__route_type'] = gtfsRouteRouteType;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List of gtfs routes.
         * @summary List 
         * @param {number} [limit] Limit the number of returned results. If not specified will limit to 100 results. To get more results, you can either use the offset param, alternatively - set the limit to -1 and use http streaming with compatible json streaming decoder to get all results, this method can fetch up to a maximum of 500000 results.
         * @param {number} [offset] Item number to start returning results from. Use in combination with limit for pagination, alternatively, don\&#39;t set offset, set limit to -1 and use http streaming with compatible json streaming decoder to get all results up to a maximum of 500000 results.
         * @param {boolean} [getCount] Set to \&quot;true\&quot; to only get the total number of results for given filters. limit/offset/order parameters will be ignored.
         * @param {string} [dateFrom]   Filter by date. Only return items which have a date after or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
         * @param {string} [dateTo]   Filter by date. Only return items which have a date before or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
         * @param {string} [lineRefs]   Filter by line ref. Comma-separated list of values.
         * @param {string} [operatorRefs] Agency identifier. To get it, first query gtfs_agencies.  Filter by operator ref. Comma-separated list of values.  Example: 3 for Eged
         * @param {string} [routeShortName] Line number.  Filter by route short name. Only return items which exactly match given string.  Example: 480
         * @param {string} [routeLongNameContains]   Filter by route long name. Only return items which contain given string.
         * @param {string} [routeMkt]   Filter by route mkt. Only return items which exactly match given string.
         * @param {string} [routeDirection]   Filter by route direction. Only return items which exactly match given string.
         * @param {string} [routeAlternative]   Filter by route alternative. Only return items which exactly match given string.
         * @param {string} [agencyName]   Filter by agency name. Only return items which exactly match given string.
         * @param {string} [routeType]   Filter by route type. Only return items which exactly match given string.
         * @param {string} [orderBy] Order of the results. Comma-separated list of fields and direction. e.g. \&quot;field1 asc,field2 desc\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGtfsRoutesListGet: async (limit?: number, offset?: number, getCount?: boolean, dateFrom?: string, dateTo?: string, lineRefs?: string, operatorRefs?: string, routeShortName?: string, routeLongNameContains?: string, routeMkt?: string, routeDirection?: string, routeAlternative?: string, agencyName?: string, routeType?: string, orderBy?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/gtfs_routes/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (getCount !== undefined) {
                localVarQueryParameter['get_count'] = getCount;
            }

            if (dateFrom !== undefined) {
                localVarQueryParameter['date_from'] = (dateFrom as any instanceof Date) ?
                    (dateFrom as any).toISOString().substring(0,10) :
                    dateFrom;
            }

            if (dateTo !== undefined) {
                localVarQueryParameter['date_to'] = (dateTo as any instanceof Date) ?
                    (dateTo as any).toISOString().substring(0,10) :
                    dateTo;
            }

            if (lineRefs !== undefined) {
                localVarQueryParameter['line_refs'] = lineRefs;
            }

            if (operatorRefs !== undefined) {
                localVarQueryParameter['operator_refs'] = operatorRefs;
            }

            if (routeShortName !== undefined) {
                localVarQueryParameter['route_short_name'] = routeShortName;
            }

            if (routeLongNameContains !== undefined) {
                localVarQueryParameter['route_long_name_contains'] = routeLongNameContains;
            }

            if (routeMkt !== undefined) {
                localVarQueryParameter['route_mkt'] = routeMkt;
            }

            if (routeDirection !== undefined) {
                localVarQueryParameter['route_direction'] = routeDirection;
            }

            if (routeAlternative !== undefined) {
                localVarQueryParameter['route_alternative'] = routeAlternative;
            }

            if (agencyName !== undefined) {
                localVarQueryParameter['agency_name'] = agencyName;
            }

            if (routeType !== undefined) {
                localVarQueryParameter['route_type'] = routeType;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List of gtfs stops.
         * @summary List 
         * @param {number} [limit] Limit the number of returned results. If not specified will limit to 100 results. To get more results, you can either use the offset param, alternatively - set the limit to -1 and use http streaming with compatible json streaming decoder to get all results, this method can fetch up to a maximum of 500000 results.
         * @param {number} [offset] Item number to start returning results from. Use in combination with limit for pagination, alternatively, don\&#39;t set offset, set limit to -1 and use http streaming with compatible json streaming decoder to get all results up to a maximum of 500000 results.
         * @param {boolean} [getCount] Set to \&quot;true\&quot; to only get the total number of results for given filters. limit/offset/order parameters will be ignored.
         * @param {string} [dateFrom]   Filter by date. Only return items which have a date after or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
         * @param {string} [dateTo]   Filter by date. Only return items which have a date before or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
         * @param {number} [code]   Filter by code. Only return items which exactly match given string.
         * @param {string} [city]   Filter by city. Only return items which exactly match given string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGtfsStopsListGet: async (limit?: number, offset?: number, getCount?: boolean, dateFrom?: string, dateTo?: string, code?: number, city?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/gtfs_stops/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (getCount !== undefined) {
                localVarQueryParameter['get_count'] = getCount;
            }

            if (dateFrom !== undefined) {
                localVarQueryParameter['date_from'] = (dateFrom as any instanceof Date) ?
                    (dateFrom as any).toISOString().substring(0,10) :
                    dateFrom;
            }

            if (dateTo !== undefined) {
                localVarQueryParameter['date_to'] = (dateTo as any instanceof Date) ?
                    (dateTo as any).toISOString().substring(0,10) :
                    dateTo;
            }

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }

            if (city !== undefined) {
                localVarQueryParameter['city'] = city;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GtfsApi - functional programming interface
 * @export
 */
export const GtfsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GtfsApiAxiosParamCreator(configuration)
    return {
        /**
         * Return a single gtfs ride stop based on id
         * @summary Get 
         * @param {number} id gtfs ride stop id to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGtfsRideStopsGetGet(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GtfsRideStopPydanticModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGtfsRideStopsGetGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GtfsApi.getGtfsRideStopsGetGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return a single gtfs ride based on id
         * @summary Get 
         * @param {number} id gtfs ride id to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGtfsRidesGetGet(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GtfsRidePydanticModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGtfsRidesGetGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GtfsApi.getGtfsRidesGetGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return a single gtfs route based on id
         * @summary Get 
         * @param {number} id gtfs route id to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGtfsRoutesGetGet(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GtfsRoutePydanticModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGtfsRoutesGetGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GtfsApi.getGtfsRoutesGetGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return a single gtfs stop based on id
         * @summary Get 
         * @param {number} id gtfs stop id to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGtfsStopsGetGet(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GtfsStopPydanticModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGtfsStopsGetGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GtfsApi.getGtfsStopsGetGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List of gtfs agencies.
         * @summary List 
         * @param {number} [limit] Limit the number of returned results. If not specified will limit to 100 results. To get more results, you can either use the offset param, alternatively - set the limit to -1 and use http streaming with compatible json streaming decoder to get all results, this method can fetch up to a maximum of 500000 results.
         * @param {number} [offset] Item number to start returning results from. Use in combination with limit for pagination, alternatively, don\&#39;t set offset, set limit to -1 and use http streaming with compatible json streaming decoder to get all results up to a maximum of 500000 results.
         * @param {string} [dateFrom]   Filter by date. Only return items which have a date after or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
         * @param {string} [dateTo]   Filter by date. Only return items which have a date before or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGtfsAgenciesListGet(limit?: number, offset?: number, dateFrom?: string, dateTo?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GtfsAgencyPydanticModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGtfsAgenciesListGet(limit, offset, dateFrom, dateTo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GtfsApi.listGtfsAgenciesListGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List of gtfs ride stops.  Due to large number of items in the table, you must filter the results by at least one of the following:  1. gtfs_ride_ids - containing a single gtfs ride id. 2. arrival_time_from and arrival_time_to - containing a time range.  Additional filters can be applied in addition to one of the above options to narrow down the results.
         * @summary List 
         * @param {number} [limit] Limit the number of returned results. If not specified will limit to 100 results. To get more results, you can either use the offset param, alternatively - set the limit to -1 and use http streaming with compatible json streaming decoder to get all results, this method can fetch up to a maximum of 500000 results.
         * @param {number} [offset] Item number to start returning results from. Use in combination with limit for pagination, alternatively, don\&#39;t set offset, set limit to -1 and use http streaming with compatible json streaming decoder to get all results up to a maximum of 500000 results.
         * @param {boolean} [getCount] Set to \&quot;true\&quot; to only get the total number of results for given filters. limit/offset/order parameters will be ignored.
         * @param {string} [arrivalTimeFrom]   Filter by arrival time from. Only return items which have date/time after or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
         * @param {string} [arrivalTimeTo]   Filter by arrival time to. Only return items which have date/time before or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
         * @param {string} [gtfsStopIds]   Filter by gtfs stop id. Comma-separated list of values.
         * @param {string} [gtfsRideIds]   Filter by gtfs ride id. Comma-separated list of values.
         * @param {number} [gtfsRideGtfsRouteId]   Filter by related gtfs ride\&#39;s gtfs route id. Only return items which exactly match given string.
         * @param {string} [gtfsRideJourneyRefPrefix]   Filter by related gtfs ride\&#39;s journey ref prefix. Only return items which start with given string.
         * @param {string} [gtfsRideStartTimeFrom]   Filter by related gtfs ride\&#39;s start time from. Only return items which have date/time after or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
         * @param {string} [gtfsRideStartTimeTo]   Filter by related gtfs ride\&#39;s start time to. Only return items which have date/time before or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
         * @param {string} [gtfsStopDateFrom]   Filter by related gtfs stop\&#39;s date. Only return items which have a date after or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
         * @param {string} [gtfsStopDateTo]   Filter by related gtfs stop\&#39;s date. Only return items which have a date before or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
         * @param {number} [gtfsStopCode]   Filter by related gtfs stop\&#39;s code. Only return items which exactly match given string.
         * @param {string} [gtfsStopCity]   Filter by related gtfs stop\&#39;s city. Only return items which exactly match given string.
         * @param {string} [gtfsRouteDateFrom]   Filter by related gtfs route\&#39;s date. Only return items which have a date after or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
         * @param {string} [gtfsRouteDateTo]   Filter by related gtfs route\&#39;s date. Only return items which have a date before or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
         * @param {string} [gtfsRouteLineRefs]   Filter by related gtfs route\&#39;s line ref. Comma-separated list of values.
         * @param {string} [gtfsRouteOperatorRefs] Agency identifier. To get it, first query gtfs_agencies.  Filter by related gtfs route\&#39;s operator ref. Comma-separated list of values.  Example: 3 for Eged
         * @param {string} [gtfsRouteRouteShortName] Line number.  Filter by related gtfs route\&#39;s route short name. Only return items which exactly match given string.  Example: 480
         * @param {string} [gtfsRouteRouteLongNameContains]   Filter by related gtfs route\&#39;s route long name. Only return items which contain given string.
         * @param {string} [gtfsRouteRouteMkt]   Filter by related gtfs route\&#39;s route mkt. Only return items which exactly match given string.
         * @param {string} [gtfsRouteRouteDirection]   Filter by related gtfs route\&#39;s route direction. Only return items which exactly match given string.
         * @param {string} [gtfsRouteRouteAlternative]   Filter by related gtfs route\&#39;s route alternative. Only return items which exactly match given string.
         * @param {string} [gtfsRouteAgencyName]   Filter by related gtfs route\&#39;s agency name. Only return items which exactly match given string.
         * @param {string} [gtfsRouteRouteType]   Filter by related gtfs route\&#39;s route type. Only return items which exactly match given string.
         * @param {string} [orderBy] Order of the results. Comma-separated list of fields and direction. e.g. \&quot;field1 asc,field2 desc\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGtfsRideStopsListGet(limit?: number, offset?: number, getCount?: boolean, arrivalTimeFrom?: string, arrivalTimeTo?: string, gtfsStopIds?: string, gtfsRideIds?: string, gtfsRideGtfsRouteId?: number, gtfsRideJourneyRefPrefix?: string, gtfsRideStartTimeFrom?: string, gtfsRideStartTimeTo?: string, gtfsStopDateFrom?: string, gtfsStopDateTo?: string, gtfsStopCode?: number, gtfsStopCity?: string, gtfsRouteDateFrom?: string, gtfsRouteDateTo?: string, gtfsRouteLineRefs?: string, gtfsRouteOperatorRefs?: string, gtfsRouteRouteShortName?: string, gtfsRouteRouteLongNameContains?: string, gtfsRouteRouteMkt?: string, gtfsRouteRouteDirection?: string, gtfsRouteRouteAlternative?: string, gtfsRouteAgencyName?: string, gtfsRouteRouteType?: string, orderBy?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GtfsRideStopWithRelatedPydanticModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGtfsRideStopsListGet(limit, offset, getCount, arrivalTimeFrom, arrivalTimeTo, gtfsStopIds, gtfsRideIds, gtfsRideGtfsRouteId, gtfsRideJourneyRefPrefix, gtfsRideStartTimeFrom, gtfsRideStartTimeTo, gtfsStopDateFrom, gtfsStopDateTo, gtfsStopCode, gtfsStopCity, gtfsRouteDateFrom, gtfsRouteDateTo, gtfsRouteLineRefs, gtfsRouteOperatorRefs, gtfsRouteRouteShortName, gtfsRouteRouteLongNameContains, gtfsRouteRouteMkt, gtfsRouteRouteDirection, gtfsRouteRouteAlternative, gtfsRouteAgencyName, gtfsRouteRouteType, orderBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GtfsApi.listGtfsRideStopsListGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List of gtfs rides.
         * @summary List 
         * @param {number} [limit] Limit the number of returned results. If not specified will limit to 100 results. To get more results, you can either use the offset param, alternatively - set the limit to -1 and use http streaming with compatible json streaming decoder to get all results, this method can fetch up to a maximum of 500000 results.
         * @param {number} [offset] Item number to start returning results from. Use in combination with limit for pagination, alternatively, don\&#39;t set offset, set limit to -1 and use http streaming with compatible json streaming decoder to get all results up to a maximum of 500000 results.
         * @param {boolean} [getCount] Set to \&quot;true\&quot; to only get the total number of results for given filters. limit/offset/order parameters will be ignored.
         * @param {number} [gtfsRouteId]   Filter by gtfs route id. Only return items which exactly match given string.
         * @param {string} [journeyRefPrefix]   Filter by journey ref prefix. Only return items which start with given string.
         * @param {string} [startTimeFrom]   Filter by start time from. Only return items which have date/time after or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
         * @param {string} [startTimeTo]   Filter by start time to. Only return items which have date/time before or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
         * @param {string} [gtfsRouteDateFrom]   Filter by related gtfs route\&#39;s date. Only return items which have a date after or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
         * @param {string} [gtfsRouteDateTo]   Filter by related gtfs route\&#39;s date. Only return items which have a date before or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
         * @param {string} [gtfsRouteLineRefs]   Filter by related gtfs route\&#39;s line ref. Comma-separated list of values.
         * @param {string} [gtfsRouteOperatorRefs] Agency identifier. To get it, first query gtfs_agencies.  Filter by related gtfs route\&#39;s operator ref. Comma-separated list of values.  Example: 3 for Eged
         * @param {string} [gtfsRouteRouteShortName] Line number.  Filter by related gtfs route\&#39;s route short name. Only return items which exactly match given string.  Example: 480
         * @param {string} [gtfsRouteRouteLongNameContains]   Filter by related gtfs route\&#39;s route long name. Only return items which contain given string.
         * @param {string} [gtfsRouteRouteMkt]   Filter by related gtfs route\&#39;s route mkt. Only return items which exactly match given string.
         * @param {string} [gtfsRouteRouteDirection]   Filter by related gtfs route\&#39;s route direction. Only return items which exactly match given string.
         * @param {string} [gtfsRouteRouteAlternative]   Filter by related gtfs route\&#39;s route alternative. Only return items which exactly match given string.
         * @param {string} [gtfsRouteAgencyName]   Filter by related gtfs route\&#39;s agency name. Only return items which exactly match given string.
         * @param {string} [gtfsRouteRouteType]   Filter by related gtfs route\&#39;s route type. Only return items which exactly match given string.
         * @param {string} [orderBy] Order of the results. Comma-separated list of fields and direction. e.g. \&quot;field1 asc,field2 desc\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGtfsRidesListGet(limit?: number, offset?: number, getCount?: boolean, gtfsRouteId?: number, journeyRefPrefix?: string, startTimeFrom?: string, startTimeTo?: string, gtfsRouteDateFrom?: string, gtfsRouteDateTo?: string, gtfsRouteLineRefs?: string, gtfsRouteOperatorRefs?: string, gtfsRouteRouteShortName?: string, gtfsRouteRouteLongNameContains?: string, gtfsRouteRouteMkt?: string, gtfsRouteRouteDirection?: string, gtfsRouteRouteAlternative?: string, gtfsRouteAgencyName?: string, gtfsRouteRouteType?: string, orderBy?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GtfsRideWithRelatedPydanticModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGtfsRidesListGet(limit, offset, getCount, gtfsRouteId, journeyRefPrefix, startTimeFrom, startTimeTo, gtfsRouteDateFrom, gtfsRouteDateTo, gtfsRouteLineRefs, gtfsRouteOperatorRefs, gtfsRouteRouteShortName, gtfsRouteRouteLongNameContains, gtfsRouteRouteMkt, gtfsRouteRouteDirection, gtfsRouteRouteAlternative, gtfsRouteAgencyName, gtfsRouteRouteType, orderBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GtfsApi.listGtfsRidesListGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List of gtfs routes.
         * @summary List 
         * @param {number} [limit] Limit the number of returned results. If not specified will limit to 100 results. To get more results, you can either use the offset param, alternatively - set the limit to -1 and use http streaming with compatible json streaming decoder to get all results, this method can fetch up to a maximum of 500000 results.
         * @param {number} [offset] Item number to start returning results from. Use in combination with limit for pagination, alternatively, don\&#39;t set offset, set limit to -1 and use http streaming with compatible json streaming decoder to get all results up to a maximum of 500000 results.
         * @param {boolean} [getCount] Set to \&quot;true\&quot; to only get the total number of results for given filters. limit/offset/order parameters will be ignored.
         * @param {string} [dateFrom]   Filter by date. Only return items which have a date after or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
         * @param {string} [dateTo]   Filter by date. Only return items which have a date before or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
         * @param {string} [lineRefs]   Filter by line ref. Comma-separated list of values.
         * @param {string} [operatorRefs] Agency identifier. To get it, first query gtfs_agencies.  Filter by operator ref. Comma-separated list of values.  Example: 3 for Eged
         * @param {string} [routeShortName] Line number.  Filter by route short name. Only return items which exactly match given string.  Example: 480
         * @param {string} [routeLongNameContains]   Filter by route long name. Only return items which contain given string.
         * @param {string} [routeMkt]   Filter by route mkt. Only return items which exactly match given string.
         * @param {string} [routeDirection]   Filter by route direction. Only return items which exactly match given string.
         * @param {string} [routeAlternative]   Filter by route alternative. Only return items which exactly match given string.
         * @param {string} [agencyName]   Filter by agency name. Only return items which exactly match given string.
         * @param {string} [routeType]   Filter by route type. Only return items which exactly match given string.
         * @param {string} [orderBy] Order of the results. Comma-separated list of fields and direction. e.g. \&quot;field1 asc,field2 desc\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGtfsRoutesListGet(limit?: number, offset?: number, getCount?: boolean, dateFrom?: string, dateTo?: string, lineRefs?: string, operatorRefs?: string, routeShortName?: string, routeLongNameContains?: string, routeMkt?: string, routeDirection?: string, routeAlternative?: string, agencyName?: string, routeType?: string, orderBy?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GtfsRoutePydanticModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGtfsRoutesListGet(limit, offset, getCount, dateFrom, dateTo, lineRefs, operatorRefs, routeShortName, routeLongNameContains, routeMkt, routeDirection, routeAlternative, agencyName, routeType, orderBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GtfsApi.listGtfsRoutesListGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List of gtfs stops.
         * @summary List 
         * @param {number} [limit] Limit the number of returned results. If not specified will limit to 100 results. To get more results, you can either use the offset param, alternatively - set the limit to -1 and use http streaming with compatible json streaming decoder to get all results, this method can fetch up to a maximum of 500000 results.
         * @param {number} [offset] Item number to start returning results from. Use in combination with limit for pagination, alternatively, don\&#39;t set offset, set limit to -1 and use http streaming with compatible json streaming decoder to get all results up to a maximum of 500000 results.
         * @param {boolean} [getCount] Set to \&quot;true\&quot; to only get the total number of results for given filters. limit/offset/order parameters will be ignored.
         * @param {string} [dateFrom]   Filter by date. Only return items which have a date after or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
         * @param {string} [dateTo]   Filter by date. Only return items which have a date before or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
         * @param {number} [code]   Filter by code. Only return items which exactly match given string.
         * @param {string} [city]   Filter by city. Only return items which exactly match given string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGtfsStopsListGet(limit?: number, offset?: number, getCount?: boolean, dateFrom?: string, dateTo?: string, code?: number, city?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GtfsStopPydanticModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGtfsStopsListGet(limit, offset, getCount, dateFrom, dateTo, code, city, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GtfsApi.listGtfsStopsListGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GtfsApi - factory interface
 * @export
 */
export const GtfsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GtfsApiFp(configuration)
    return {
        /**
         * Return a single gtfs ride stop based on id
         * @summary Get 
         * @param {number} id gtfs ride stop id to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGtfsRideStopsGetGet(id: number, options?: RawAxiosRequestConfig): AxiosPromise<GtfsRideStopPydanticModel> {
            return localVarFp.getGtfsRideStopsGetGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Return a single gtfs ride based on id
         * @summary Get 
         * @param {number} id gtfs ride id to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGtfsRidesGetGet(id: number, options?: RawAxiosRequestConfig): AxiosPromise<GtfsRidePydanticModel> {
            return localVarFp.getGtfsRidesGetGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Return a single gtfs route based on id
         * @summary Get 
         * @param {number} id gtfs route id to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGtfsRoutesGetGet(id: number, options?: RawAxiosRequestConfig): AxiosPromise<GtfsRoutePydanticModel> {
            return localVarFp.getGtfsRoutesGetGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Return a single gtfs stop based on id
         * @summary Get 
         * @param {number} id gtfs stop id to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGtfsStopsGetGet(id: number, options?: RawAxiosRequestConfig): AxiosPromise<GtfsStopPydanticModel> {
            return localVarFp.getGtfsStopsGetGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * List of gtfs agencies.
         * @summary List 
         * @param {number} [limit] Limit the number of returned results. If not specified will limit to 100 results. To get more results, you can either use the offset param, alternatively - set the limit to -1 and use http streaming with compatible json streaming decoder to get all results, this method can fetch up to a maximum of 500000 results.
         * @param {number} [offset] Item number to start returning results from. Use in combination with limit for pagination, alternatively, don\&#39;t set offset, set limit to -1 and use http streaming with compatible json streaming decoder to get all results up to a maximum of 500000 results.
         * @param {string} [dateFrom]   Filter by date. Only return items which have a date after or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
         * @param {string} [dateTo]   Filter by date. Only return items which have a date before or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGtfsAgenciesListGet(limit?: number, offset?: number, dateFrom?: string, dateTo?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GtfsAgencyPydanticModel>> {
            return localVarFp.listGtfsAgenciesListGet(limit, offset, dateFrom, dateTo, options).then((request) => request(axios, basePath));
        },
        /**
         * List of gtfs ride stops.  Due to large number of items in the table, you must filter the results by at least one of the following:  1. gtfs_ride_ids - containing a single gtfs ride id. 2. arrival_time_from and arrival_time_to - containing a time range.  Additional filters can be applied in addition to one of the above options to narrow down the results.
         * @summary List 
         * @param {number} [limit] Limit the number of returned results. If not specified will limit to 100 results. To get more results, you can either use the offset param, alternatively - set the limit to -1 and use http streaming with compatible json streaming decoder to get all results, this method can fetch up to a maximum of 500000 results.
         * @param {number} [offset] Item number to start returning results from. Use in combination with limit for pagination, alternatively, don\&#39;t set offset, set limit to -1 and use http streaming with compatible json streaming decoder to get all results up to a maximum of 500000 results.
         * @param {boolean} [getCount] Set to \&quot;true\&quot; to only get the total number of results for given filters. limit/offset/order parameters will be ignored.
         * @param {string} [arrivalTimeFrom]   Filter by arrival time from. Only return items which have date/time after or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
         * @param {string} [arrivalTimeTo]   Filter by arrival time to. Only return items which have date/time before or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
         * @param {string} [gtfsStopIds]   Filter by gtfs stop id. Comma-separated list of values.
         * @param {string} [gtfsRideIds]   Filter by gtfs ride id. Comma-separated list of values.
         * @param {number} [gtfsRideGtfsRouteId]   Filter by related gtfs ride\&#39;s gtfs route id. Only return items which exactly match given string.
         * @param {string} [gtfsRideJourneyRefPrefix]   Filter by related gtfs ride\&#39;s journey ref prefix. Only return items which start with given string.
         * @param {string} [gtfsRideStartTimeFrom]   Filter by related gtfs ride\&#39;s start time from. Only return items which have date/time after or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
         * @param {string} [gtfsRideStartTimeTo]   Filter by related gtfs ride\&#39;s start time to. Only return items which have date/time before or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
         * @param {string} [gtfsStopDateFrom]   Filter by related gtfs stop\&#39;s date. Only return items which have a date after or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
         * @param {string} [gtfsStopDateTo]   Filter by related gtfs stop\&#39;s date. Only return items which have a date before or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
         * @param {number} [gtfsStopCode]   Filter by related gtfs stop\&#39;s code. Only return items which exactly match given string.
         * @param {string} [gtfsStopCity]   Filter by related gtfs stop\&#39;s city. Only return items which exactly match given string.
         * @param {string} [gtfsRouteDateFrom]   Filter by related gtfs route\&#39;s date. Only return items which have a date after or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
         * @param {string} [gtfsRouteDateTo]   Filter by related gtfs route\&#39;s date. Only return items which have a date before or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
         * @param {string} [gtfsRouteLineRefs]   Filter by related gtfs route\&#39;s line ref. Comma-separated list of values.
         * @param {string} [gtfsRouteOperatorRefs] Agency identifier. To get it, first query gtfs_agencies.  Filter by related gtfs route\&#39;s operator ref. Comma-separated list of values.  Example: 3 for Eged
         * @param {string} [gtfsRouteRouteShortName] Line number.  Filter by related gtfs route\&#39;s route short name. Only return items which exactly match given string.  Example: 480
         * @param {string} [gtfsRouteRouteLongNameContains]   Filter by related gtfs route\&#39;s route long name. Only return items which contain given string.
         * @param {string} [gtfsRouteRouteMkt]   Filter by related gtfs route\&#39;s route mkt. Only return items which exactly match given string.
         * @param {string} [gtfsRouteRouteDirection]   Filter by related gtfs route\&#39;s route direction. Only return items which exactly match given string.
         * @param {string} [gtfsRouteRouteAlternative]   Filter by related gtfs route\&#39;s route alternative. Only return items which exactly match given string.
         * @param {string} [gtfsRouteAgencyName]   Filter by related gtfs route\&#39;s agency name. Only return items which exactly match given string.
         * @param {string} [gtfsRouteRouteType]   Filter by related gtfs route\&#39;s route type. Only return items which exactly match given string.
         * @param {string} [orderBy] Order of the results. Comma-separated list of fields and direction. e.g. \&quot;field1 asc,field2 desc\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGtfsRideStopsListGet(limit?: number, offset?: number, getCount?: boolean, arrivalTimeFrom?: string, arrivalTimeTo?: string, gtfsStopIds?: string, gtfsRideIds?: string, gtfsRideGtfsRouteId?: number, gtfsRideJourneyRefPrefix?: string, gtfsRideStartTimeFrom?: string, gtfsRideStartTimeTo?: string, gtfsStopDateFrom?: string, gtfsStopDateTo?: string, gtfsStopCode?: number, gtfsStopCity?: string, gtfsRouteDateFrom?: string, gtfsRouteDateTo?: string, gtfsRouteLineRefs?: string, gtfsRouteOperatorRefs?: string, gtfsRouteRouteShortName?: string, gtfsRouteRouteLongNameContains?: string, gtfsRouteRouteMkt?: string, gtfsRouteRouteDirection?: string, gtfsRouteRouteAlternative?: string, gtfsRouteAgencyName?: string, gtfsRouteRouteType?: string, orderBy?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GtfsRideStopWithRelatedPydanticModel>> {
            return localVarFp.listGtfsRideStopsListGet(limit, offset, getCount, arrivalTimeFrom, arrivalTimeTo, gtfsStopIds, gtfsRideIds, gtfsRideGtfsRouteId, gtfsRideJourneyRefPrefix, gtfsRideStartTimeFrom, gtfsRideStartTimeTo, gtfsStopDateFrom, gtfsStopDateTo, gtfsStopCode, gtfsStopCity, gtfsRouteDateFrom, gtfsRouteDateTo, gtfsRouteLineRefs, gtfsRouteOperatorRefs, gtfsRouteRouteShortName, gtfsRouteRouteLongNameContains, gtfsRouteRouteMkt, gtfsRouteRouteDirection, gtfsRouteRouteAlternative, gtfsRouteAgencyName, gtfsRouteRouteType, orderBy, options).then((request) => request(axios, basePath));
        },
        /**
         * List of gtfs rides.
         * @summary List 
         * @param {number} [limit] Limit the number of returned results. If not specified will limit to 100 results. To get more results, you can either use the offset param, alternatively - set the limit to -1 and use http streaming with compatible json streaming decoder to get all results, this method can fetch up to a maximum of 500000 results.
         * @param {number} [offset] Item number to start returning results from. Use in combination with limit for pagination, alternatively, don\&#39;t set offset, set limit to -1 and use http streaming with compatible json streaming decoder to get all results up to a maximum of 500000 results.
         * @param {boolean} [getCount] Set to \&quot;true\&quot; to only get the total number of results for given filters. limit/offset/order parameters will be ignored.
         * @param {number} [gtfsRouteId]   Filter by gtfs route id. Only return items which exactly match given string.
         * @param {string} [journeyRefPrefix]   Filter by journey ref prefix. Only return items which start with given string.
         * @param {string} [startTimeFrom]   Filter by start time from. Only return items which have date/time after or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
         * @param {string} [startTimeTo]   Filter by start time to. Only return items which have date/time before or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
         * @param {string} [gtfsRouteDateFrom]   Filter by related gtfs route\&#39;s date. Only return items which have a date after or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
         * @param {string} [gtfsRouteDateTo]   Filter by related gtfs route\&#39;s date. Only return items which have a date before or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
         * @param {string} [gtfsRouteLineRefs]   Filter by related gtfs route\&#39;s line ref. Comma-separated list of values.
         * @param {string} [gtfsRouteOperatorRefs] Agency identifier. To get it, first query gtfs_agencies.  Filter by related gtfs route\&#39;s operator ref. Comma-separated list of values.  Example: 3 for Eged
         * @param {string} [gtfsRouteRouteShortName] Line number.  Filter by related gtfs route\&#39;s route short name. Only return items which exactly match given string.  Example: 480
         * @param {string} [gtfsRouteRouteLongNameContains]   Filter by related gtfs route\&#39;s route long name. Only return items which contain given string.
         * @param {string} [gtfsRouteRouteMkt]   Filter by related gtfs route\&#39;s route mkt. Only return items which exactly match given string.
         * @param {string} [gtfsRouteRouteDirection]   Filter by related gtfs route\&#39;s route direction. Only return items which exactly match given string.
         * @param {string} [gtfsRouteRouteAlternative]   Filter by related gtfs route\&#39;s route alternative. Only return items which exactly match given string.
         * @param {string} [gtfsRouteAgencyName]   Filter by related gtfs route\&#39;s agency name. Only return items which exactly match given string.
         * @param {string} [gtfsRouteRouteType]   Filter by related gtfs route\&#39;s route type. Only return items which exactly match given string.
         * @param {string} [orderBy] Order of the results. Comma-separated list of fields and direction. e.g. \&quot;field1 asc,field2 desc\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGtfsRidesListGet(limit?: number, offset?: number, getCount?: boolean, gtfsRouteId?: number, journeyRefPrefix?: string, startTimeFrom?: string, startTimeTo?: string, gtfsRouteDateFrom?: string, gtfsRouteDateTo?: string, gtfsRouteLineRefs?: string, gtfsRouteOperatorRefs?: string, gtfsRouteRouteShortName?: string, gtfsRouteRouteLongNameContains?: string, gtfsRouteRouteMkt?: string, gtfsRouteRouteDirection?: string, gtfsRouteRouteAlternative?: string, gtfsRouteAgencyName?: string, gtfsRouteRouteType?: string, orderBy?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GtfsRideWithRelatedPydanticModel>> {
            return localVarFp.listGtfsRidesListGet(limit, offset, getCount, gtfsRouteId, journeyRefPrefix, startTimeFrom, startTimeTo, gtfsRouteDateFrom, gtfsRouteDateTo, gtfsRouteLineRefs, gtfsRouteOperatorRefs, gtfsRouteRouteShortName, gtfsRouteRouteLongNameContains, gtfsRouteRouteMkt, gtfsRouteRouteDirection, gtfsRouteRouteAlternative, gtfsRouteAgencyName, gtfsRouteRouteType, orderBy, options).then((request) => request(axios, basePath));
        },
        /**
         * List of gtfs routes.
         * @summary List 
         * @param {number} [limit] Limit the number of returned results. If not specified will limit to 100 results. To get more results, you can either use the offset param, alternatively - set the limit to -1 and use http streaming with compatible json streaming decoder to get all results, this method can fetch up to a maximum of 500000 results.
         * @param {number} [offset] Item number to start returning results from. Use in combination with limit for pagination, alternatively, don\&#39;t set offset, set limit to -1 and use http streaming with compatible json streaming decoder to get all results up to a maximum of 500000 results.
         * @param {boolean} [getCount] Set to \&quot;true\&quot; to only get the total number of results for given filters. limit/offset/order parameters will be ignored.
         * @param {string} [dateFrom]   Filter by date. Only return items which have a date after or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
         * @param {string} [dateTo]   Filter by date. Only return items which have a date before or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
         * @param {string} [lineRefs]   Filter by line ref. Comma-separated list of values.
         * @param {string} [operatorRefs] Agency identifier. To get it, first query gtfs_agencies.  Filter by operator ref. Comma-separated list of values.  Example: 3 for Eged
         * @param {string} [routeShortName] Line number.  Filter by route short name. Only return items which exactly match given string.  Example: 480
         * @param {string} [routeLongNameContains]   Filter by route long name. Only return items which contain given string.
         * @param {string} [routeMkt]   Filter by route mkt. Only return items which exactly match given string.
         * @param {string} [routeDirection]   Filter by route direction. Only return items which exactly match given string.
         * @param {string} [routeAlternative]   Filter by route alternative. Only return items which exactly match given string.
         * @param {string} [agencyName]   Filter by agency name. Only return items which exactly match given string.
         * @param {string} [routeType]   Filter by route type. Only return items which exactly match given string.
         * @param {string} [orderBy] Order of the results. Comma-separated list of fields and direction. e.g. \&quot;field1 asc,field2 desc\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGtfsRoutesListGet(limit?: number, offset?: number, getCount?: boolean, dateFrom?: string, dateTo?: string, lineRefs?: string, operatorRefs?: string, routeShortName?: string, routeLongNameContains?: string, routeMkt?: string, routeDirection?: string, routeAlternative?: string, agencyName?: string, routeType?: string, orderBy?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GtfsRoutePydanticModel>> {
            return localVarFp.listGtfsRoutesListGet(limit, offset, getCount, dateFrom, dateTo, lineRefs, operatorRefs, routeShortName, routeLongNameContains, routeMkt, routeDirection, routeAlternative, agencyName, routeType, orderBy, options).then((request) => request(axios, basePath));
        },
        /**
         * List of gtfs stops.
         * @summary List 
         * @param {number} [limit] Limit the number of returned results. If not specified will limit to 100 results. To get more results, you can either use the offset param, alternatively - set the limit to -1 and use http streaming with compatible json streaming decoder to get all results, this method can fetch up to a maximum of 500000 results.
         * @param {number} [offset] Item number to start returning results from. Use in combination with limit for pagination, alternatively, don\&#39;t set offset, set limit to -1 and use http streaming with compatible json streaming decoder to get all results up to a maximum of 500000 results.
         * @param {boolean} [getCount] Set to \&quot;true\&quot; to only get the total number of results for given filters. limit/offset/order parameters will be ignored.
         * @param {string} [dateFrom]   Filter by date. Only return items which have a date after or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
         * @param {string} [dateTo]   Filter by date. Only return items which have a date before or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
         * @param {number} [code]   Filter by code. Only return items which exactly match given string.
         * @param {string} [city]   Filter by city. Only return items which exactly match given string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGtfsStopsListGet(limit?: number, offset?: number, getCount?: boolean, dateFrom?: string, dateTo?: string, code?: number, city?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GtfsStopPydanticModel>> {
            return localVarFp.listGtfsStopsListGet(limit, offset, getCount, dateFrom, dateTo, code, city, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GtfsApi - object-oriented interface
 * @export
 * @class GtfsApi
 * @extends {BaseAPI}
 */
export class GtfsApi extends BaseAPI {
    /**
     * Return a single gtfs ride stop based on id
     * @summary Get 
     * @param {number} id gtfs ride stop id to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GtfsApi
     */
    public getGtfsRideStopsGetGet(id: number, options?: RawAxiosRequestConfig) {
        return GtfsApiFp(this.configuration).getGtfsRideStopsGetGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return a single gtfs ride based on id
     * @summary Get 
     * @param {number} id gtfs ride id to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GtfsApi
     */
    public getGtfsRidesGetGet(id: number, options?: RawAxiosRequestConfig) {
        return GtfsApiFp(this.configuration).getGtfsRidesGetGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return a single gtfs route based on id
     * @summary Get 
     * @param {number} id gtfs route id to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GtfsApi
     */
    public getGtfsRoutesGetGet(id: number, options?: RawAxiosRequestConfig) {
        return GtfsApiFp(this.configuration).getGtfsRoutesGetGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return a single gtfs stop based on id
     * @summary Get 
     * @param {number} id gtfs stop id to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GtfsApi
     */
    public getGtfsStopsGetGet(id: number, options?: RawAxiosRequestConfig) {
        return GtfsApiFp(this.configuration).getGtfsStopsGetGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List of gtfs agencies.
     * @summary List 
     * @param {number} [limit] Limit the number of returned results. If not specified will limit to 100 results. To get more results, you can either use the offset param, alternatively - set the limit to -1 and use http streaming with compatible json streaming decoder to get all results, this method can fetch up to a maximum of 500000 results.
     * @param {number} [offset] Item number to start returning results from. Use in combination with limit for pagination, alternatively, don\&#39;t set offset, set limit to -1 and use http streaming with compatible json streaming decoder to get all results up to a maximum of 500000 results.
     * @param {string} [dateFrom]   Filter by date. Only return items which have a date after or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
     * @param {string} [dateTo]   Filter by date. Only return items which have a date before or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GtfsApi
     */
    public listGtfsAgenciesListGet(limit?: number, offset?: number, dateFrom?: string, dateTo?: string, options?: RawAxiosRequestConfig) {
        return GtfsApiFp(this.configuration).listGtfsAgenciesListGet(limit, offset, dateFrom, dateTo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List of gtfs ride stops.  Due to large number of items in the table, you must filter the results by at least one of the following:  1. gtfs_ride_ids - containing a single gtfs ride id. 2. arrival_time_from and arrival_time_to - containing a time range.  Additional filters can be applied in addition to one of the above options to narrow down the results.
     * @summary List 
     * @param {number} [limit] Limit the number of returned results. If not specified will limit to 100 results. To get more results, you can either use the offset param, alternatively - set the limit to -1 and use http streaming with compatible json streaming decoder to get all results, this method can fetch up to a maximum of 500000 results.
     * @param {number} [offset] Item number to start returning results from. Use in combination with limit for pagination, alternatively, don\&#39;t set offset, set limit to -1 and use http streaming with compatible json streaming decoder to get all results up to a maximum of 500000 results.
     * @param {boolean} [getCount] Set to \&quot;true\&quot; to only get the total number of results for given filters. limit/offset/order parameters will be ignored.
     * @param {string} [arrivalTimeFrom]   Filter by arrival time from. Only return items which have date/time after or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
     * @param {string} [arrivalTimeTo]   Filter by arrival time to. Only return items which have date/time before or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
     * @param {string} [gtfsStopIds]   Filter by gtfs stop id. Comma-separated list of values.
     * @param {string} [gtfsRideIds]   Filter by gtfs ride id. Comma-separated list of values.
     * @param {number} [gtfsRideGtfsRouteId]   Filter by related gtfs ride\&#39;s gtfs route id. Only return items which exactly match given string.
     * @param {string} [gtfsRideJourneyRefPrefix]   Filter by related gtfs ride\&#39;s journey ref prefix. Only return items which start with given string.
     * @param {string} [gtfsRideStartTimeFrom]   Filter by related gtfs ride\&#39;s start time from. Only return items which have date/time after or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
     * @param {string} [gtfsRideStartTimeTo]   Filter by related gtfs ride\&#39;s start time to. Only return items which have date/time before or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
     * @param {string} [gtfsStopDateFrom]   Filter by related gtfs stop\&#39;s date. Only return items which have a date after or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
     * @param {string} [gtfsStopDateTo]   Filter by related gtfs stop\&#39;s date. Only return items which have a date before or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
     * @param {number} [gtfsStopCode]   Filter by related gtfs stop\&#39;s code. Only return items which exactly match given string.
     * @param {string} [gtfsStopCity]   Filter by related gtfs stop\&#39;s city. Only return items which exactly match given string.
     * @param {string} [gtfsRouteDateFrom]   Filter by related gtfs route\&#39;s date. Only return items which have a date after or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
     * @param {string} [gtfsRouteDateTo]   Filter by related gtfs route\&#39;s date. Only return items which have a date before or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
     * @param {string} [gtfsRouteLineRefs]   Filter by related gtfs route\&#39;s line ref. Comma-separated list of values.
     * @param {string} [gtfsRouteOperatorRefs] Agency identifier. To get it, first query gtfs_agencies.  Filter by related gtfs route\&#39;s operator ref. Comma-separated list of values.  Example: 3 for Eged
     * @param {string} [gtfsRouteRouteShortName] Line number.  Filter by related gtfs route\&#39;s route short name. Only return items which exactly match given string.  Example: 480
     * @param {string} [gtfsRouteRouteLongNameContains]   Filter by related gtfs route\&#39;s route long name. Only return items which contain given string.
     * @param {string} [gtfsRouteRouteMkt]   Filter by related gtfs route\&#39;s route mkt. Only return items which exactly match given string.
     * @param {string} [gtfsRouteRouteDirection]   Filter by related gtfs route\&#39;s route direction. Only return items which exactly match given string.
     * @param {string} [gtfsRouteRouteAlternative]   Filter by related gtfs route\&#39;s route alternative. Only return items which exactly match given string.
     * @param {string} [gtfsRouteAgencyName]   Filter by related gtfs route\&#39;s agency name. Only return items which exactly match given string.
     * @param {string} [gtfsRouteRouteType]   Filter by related gtfs route\&#39;s route type. Only return items which exactly match given string.
     * @param {string} [orderBy] Order of the results. Comma-separated list of fields and direction. e.g. \&quot;field1 asc,field2 desc\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GtfsApi
     */
    public listGtfsRideStopsListGet(limit?: number, offset?: number, getCount?: boolean, arrivalTimeFrom?: string, arrivalTimeTo?: string, gtfsStopIds?: string, gtfsRideIds?: string, gtfsRideGtfsRouteId?: number, gtfsRideJourneyRefPrefix?: string, gtfsRideStartTimeFrom?: string, gtfsRideStartTimeTo?: string, gtfsStopDateFrom?: string, gtfsStopDateTo?: string, gtfsStopCode?: number, gtfsStopCity?: string, gtfsRouteDateFrom?: string, gtfsRouteDateTo?: string, gtfsRouteLineRefs?: string, gtfsRouteOperatorRefs?: string, gtfsRouteRouteShortName?: string, gtfsRouteRouteLongNameContains?: string, gtfsRouteRouteMkt?: string, gtfsRouteRouteDirection?: string, gtfsRouteRouteAlternative?: string, gtfsRouteAgencyName?: string, gtfsRouteRouteType?: string, orderBy?: string, options?: RawAxiosRequestConfig) {
        return GtfsApiFp(this.configuration).listGtfsRideStopsListGet(limit, offset, getCount, arrivalTimeFrom, arrivalTimeTo, gtfsStopIds, gtfsRideIds, gtfsRideGtfsRouteId, gtfsRideJourneyRefPrefix, gtfsRideStartTimeFrom, gtfsRideStartTimeTo, gtfsStopDateFrom, gtfsStopDateTo, gtfsStopCode, gtfsStopCity, gtfsRouteDateFrom, gtfsRouteDateTo, gtfsRouteLineRefs, gtfsRouteOperatorRefs, gtfsRouteRouteShortName, gtfsRouteRouteLongNameContains, gtfsRouteRouteMkt, gtfsRouteRouteDirection, gtfsRouteRouteAlternative, gtfsRouteAgencyName, gtfsRouteRouteType, orderBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List of gtfs rides.
     * @summary List 
     * @param {number} [limit] Limit the number of returned results. If not specified will limit to 100 results. To get more results, you can either use the offset param, alternatively - set the limit to -1 and use http streaming with compatible json streaming decoder to get all results, this method can fetch up to a maximum of 500000 results.
     * @param {number} [offset] Item number to start returning results from. Use in combination with limit for pagination, alternatively, don\&#39;t set offset, set limit to -1 and use http streaming with compatible json streaming decoder to get all results up to a maximum of 500000 results.
     * @param {boolean} [getCount] Set to \&quot;true\&quot; to only get the total number of results for given filters. limit/offset/order parameters will be ignored.
     * @param {number} [gtfsRouteId]   Filter by gtfs route id. Only return items which exactly match given string.
     * @param {string} [journeyRefPrefix]   Filter by journey ref prefix. Only return items which start with given string.
     * @param {string} [startTimeFrom]   Filter by start time from. Only return items which have date/time after or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
     * @param {string} [startTimeTo]   Filter by start time to. Only return items which have date/time before or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
     * @param {string} [gtfsRouteDateFrom]   Filter by related gtfs route\&#39;s date. Only return items which have a date after or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
     * @param {string} [gtfsRouteDateTo]   Filter by related gtfs route\&#39;s date. Only return items which have a date before or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
     * @param {string} [gtfsRouteLineRefs]   Filter by related gtfs route\&#39;s line ref. Comma-separated list of values.
     * @param {string} [gtfsRouteOperatorRefs] Agency identifier. To get it, first query gtfs_agencies.  Filter by related gtfs route\&#39;s operator ref. Comma-separated list of values.  Example: 3 for Eged
     * @param {string} [gtfsRouteRouteShortName] Line number.  Filter by related gtfs route\&#39;s route short name. Only return items which exactly match given string.  Example: 480
     * @param {string} [gtfsRouteRouteLongNameContains]   Filter by related gtfs route\&#39;s route long name. Only return items which contain given string.
     * @param {string} [gtfsRouteRouteMkt]   Filter by related gtfs route\&#39;s route mkt. Only return items which exactly match given string.
     * @param {string} [gtfsRouteRouteDirection]   Filter by related gtfs route\&#39;s route direction. Only return items which exactly match given string.
     * @param {string} [gtfsRouteRouteAlternative]   Filter by related gtfs route\&#39;s route alternative. Only return items which exactly match given string.
     * @param {string} [gtfsRouteAgencyName]   Filter by related gtfs route\&#39;s agency name. Only return items which exactly match given string.
     * @param {string} [gtfsRouteRouteType]   Filter by related gtfs route\&#39;s route type. Only return items which exactly match given string.
     * @param {string} [orderBy] Order of the results. Comma-separated list of fields and direction. e.g. \&quot;field1 asc,field2 desc\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GtfsApi
     */
    public listGtfsRidesListGet(limit?: number, offset?: number, getCount?: boolean, gtfsRouteId?: number, journeyRefPrefix?: string, startTimeFrom?: string, startTimeTo?: string, gtfsRouteDateFrom?: string, gtfsRouteDateTo?: string, gtfsRouteLineRefs?: string, gtfsRouteOperatorRefs?: string, gtfsRouteRouteShortName?: string, gtfsRouteRouteLongNameContains?: string, gtfsRouteRouteMkt?: string, gtfsRouteRouteDirection?: string, gtfsRouteRouteAlternative?: string, gtfsRouteAgencyName?: string, gtfsRouteRouteType?: string, orderBy?: string, options?: RawAxiosRequestConfig) {
        return GtfsApiFp(this.configuration).listGtfsRidesListGet(limit, offset, getCount, gtfsRouteId, journeyRefPrefix, startTimeFrom, startTimeTo, gtfsRouteDateFrom, gtfsRouteDateTo, gtfsRouteLineRefs, gtfsRouteOperatorRefs, gtfsRouteRouteShortName, gtfsRouteRouteLongNameContains, gtfsRouteRouteMkt, gtfsRouteRouteDirection, gtfsRouteRouteAlternative, gtfsRouteAgencyName, gtfsRouteRouteType, orderBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List of gtfs routes.
     * @summary List 
     * @param {number} [limit] Limit the number of returned results. If not specified will limit to 100 results. To get more results, you can either use the offset param, alternatively - set the limit to -1 and use http streaming with compatible json streaming decoder to get all results, this method can fetch up to a maximum of 500000 results.
     * @param {number} [offset] Item number to start returning results from. Use in combination with limit for pagination, alternatively, don\&#39;t set offset, set limit to -1 and use http streaming with compatible json streaming decoder to get all results up to a maximum of 500000 results.
     * @param {boolean} [getCount] Set to \&quot;true\&quot; to only get the total number of results for given filters. limit/offset/order parameters will be ignored.
     * @param {string} [dateFrom]   Filter by date. Only return items which have a date after or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
     * @param {string} [dateTo]   Filter by date. Only return items which have a date before or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
     * @param {string} [lineRefs]   Filter by line ref. Comma-separated list of values.
     * @param {string} [operatorRefs] Agency identifier. To get it, first query gtfs_agencies.  Filter by operator ref. Comma-separated list of values.  Example: 3 for Eged
     * @param {string} [routeShortName] Line number.  Filter by route short name. Only return items which exactly match given string.  Example: 480
     * @param {string} [routeLongNameContains]   Filter by route long name. Only return items which contain given string.
     * @param {string} [routeMkt]   Filter by route mkt. Only return items which exactly match given string.
     * @param {string} [routeDirection]   Filter by route direction. Only return items which exactly match given string.
     * @param {string} [routeAlternative]   Filter by route alternative. Only return items which exactly match given string.
     * @param {string} [agencyName]   Filter by agency name. Only return items which exactly match given string.
     * @param {string} [routeType]   Filter by route type. Only return items which exactly match given string.
     * @param {string} [orderBy] Order of the results. Comma-separated list of fields and direction. e.g. \&quot;field1 asc,field2 desc\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GtfsApi
     */
    public listGtfsRoutesListGet(limit?: number, offset?: number, getCount?: boolean, dateFrom?: string, dateTo?: string, lineRefs?: string, operatorRefs?: string, routeShortName?: string, routeLongNameContains?: string, routeMkt?: string, routeDirection?: string, routeAlternative?: string, agencyName?: string, routeType?: string, orderBy?: string, options?: RawAxiosRequestConfig) {
        return GtfsApiFp(this.configuration).listGtfsRoutesListGet(limit, offset, getCount, dateFrom, dateTo, lineRefs, operatorRefs, routeShortName, routeLongNameContains, routeMkt, routeDirection, routeAlternative, agencyName, routeType, orderBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List of gtfs stops.
     * @summary List 
     * @param {number} [limit] Limit the number of returned results. If not specified will limit to 100 results. To get more results, you can either use the offset param, alternatively - set the limit to -1 and use http streaming with compatible json streaming decoder to get all results, this method can fetch up to a maximum of 500000 results.
     * @param {number} [offset] Item number to start returning results from. Use in combination with limit for pagination, alternatively, don\&#39;t set offset, set limit to -1 and use http streaming with compatible json streaming decoder to get all results up to a maximum of 500000 results.
     * @param {boolean} [getCount] Set to \&quot;true\&quot; to only get the total number of results for given filters. limit/offset/order parameters will be ignored.
     * @param {string} [dateFrom]   Filter by date. Only return items which have a date after or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
     * @param {string} [dateTo]   Filter by date. Only return items which have a date before or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
     * @param {number} [code]   Filter by code. Only return items which exactly match given string.
     * @param {string} [city]   Filter by city. Only return items which exactly match given string.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GtfsApi
     */
    public listGtfsStopsListGet(limit?: number, offset?: number, getCount?: boolean, dateFrom?: string, dateTo?: string, code?: number, city?: string, options?: RawAxiosRequestConfig) {
        return GtfsApiFp(this.configuration).listGtfsStopsListGet(limit, offset, getCount, dateFrom, dateTo, code, city, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SiriApi - axios parameter creator
 * @export
 */
export const SiriApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Return a single siri ride stop based on id
         * @summary Get 
         * @param {number} id siri ride stop id to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSiriRideStopsGetGet: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSiriRideStopsGetGet', 'id', id)
            const localVarPath = `/siri_ride_stops/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a single siri ride based on id
         * @summary Get 
         * @param {number} id siri ride id to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSiriRidesGetGet: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSiriRidesGetGet', 'id', id)
            const localVarPath = `/siri_rides/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a single siri route based on id
         * @summary Get 
         * @param {number} id siri route id to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSiriRoutesGetGet: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSiriRoutesGetGet', 'id', id)
            const localVarPath = `/siri_routes/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a single siri snapshot based on id
         * @summary Get 
         * @param {number} id siri snapshot id to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSiriSnapshotsGetGet: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSiriSnapshotsGetGet', 'id', id)
            const localVarPath = `/siri_snapshots/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a single siri stop based on id
         * @summary Get 
         * @param {number} id siri stop id to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSiriStopsGetGet: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSiriStopsGetGet', 'id', id)
            const localVarPath = `/siri_stops/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a single siri vehicle location based on id
         * @summary Get 
         * @param {number} id siri vehicle location id to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSiriVehicleLocationsGetGet: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSiriVehicleLocationsGetGet', 'id', id)
            const localVarPath = `/siri_vehicle_locations/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List of siri ride stops.
         * @summary List 
         * @param {number} [limit] Limit the number of returned results. If not specified will limit to 100 results. To get more results, you can either use the offset param, alternatively - set the limit to -1 and use http streaming with compatible json streaming decoder to get all results, this method can fetch up to a maximum of 500000 results.
         * @param {number} [offset] Item number to start returning results from. Use in combination with limit for pagination, alternatively, don\&#39;t set offset, set limit to -1 and use http streaming with compatible json streaming decoder to get all results up to a maximum of 500000 results.
         * @param {boolean} [getCount] Set to \&quot;true\&quot; to only get the total number of results for given filters. limit/offset/order parameters will be ignored.
         * @param {string} [siriStopIds]   Filter by siri stop id. Comma-separated list of values.
         * @param {string} [siriRideIds]   Filter by siri ride id. Comma-separated list of values.
         * @param {number} [siriVehicleLocationLonGreaterOrEqual]   Filter by siri vehicle location lon. Only return items which have a numeric value greater than or equal to given value  Example: 34.808
         * @param {number} [siriVehicleLocationLonLowerOrEqual]   Filter by siri vehicle location lon. Only return items which have a numeric value lower than or equal to given value  Example: 34.808
         * @param {number} [siriVehicleLocationLatGreaterOrEqual]   Filter by siri vehicle location lat. Only return items which have a numeric value greater than or equal to given value  Example: 31.961
         * @param {number} [siriVehicleLocationLatLowerOrEqual]   Filter by siri vehicle location lat. Only return items which have a numeric value lower than or equal to given value  Example: 31.961
         * @param {string} [siriVehicleLocationRecordedAtTimeFrom]   Filter by siri vehicle location recorded at time. Only return items which have date/time after or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
         * @param {string} [siriVehicleLocationRecordedAtTimeTo]   Filter by siri vehicle location recorded at time. Only return items which have date/time before or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
         * @param {string} [siriRideScheduledStartTimeFrom]   Filter by siri ride scheduled start time. Only return items which have date/time after or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
         * @param {string} [siriRideScheduledStartTimeTo]   Filter by siri ride scheduled start time. Only return items which have date/time before or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
         * @param {number} [gtfsStopLatGreaterOrEqual]   Filter by gtfs stop lat. Only return items which have a numeric value greater than or equal to given value  Example: 31.961
         * @param {number} [gtfsStopLatLowerOrEqual]   Filter by gtfs stop lat. Only return items which have a numeric value lower than or equal to given value  Example: 31.961
         * @param {number} [gtfsStopLonGreaterOrEqual]   Filter by gtfs stop lon. Only return items which have a numeric value greater than or equal to given value  Example: 34.808
         * @param {number} [gtfsStopLonLowerOrEqual]   Filter by gtfs stop lon. Only return items which have a numeric value lower than or equal to given value  Example: 34.808
         * @param {string} [gtfsDateFrom] filter all gtfs related records on this date  Filter by gtfs date. Only return items which have a date after or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
         * @param {string} [gtfsDateTo] filter all gtfs related records on this date  Filter by gtfs date. Only return items which have a date before or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
         * @param {string} [orderBy] Order of the results. Comma-separated list of fields and direction. e.g. \&quot;field1 asc,field2 desc\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSiriRideStopsListGet: async (limit?: number, offset?: number, getCount?: boolean, siriStopIds?: string, siriRideIds?: string, siriVehicleLocationLonGreaterOrEqual?: number, siriVehicleLocationLonLowerOrEqual?: number, siriVehicleLocationLatGreaterOrEqual?: number, siriVehicleLocationLatLowerOrEqual?: number, siriVehicleLocationRecordedAtTimeFrom?: string, siriVehicleLocationRecordedAtTimeTo?: string, siriRideScheduledStartTimeFrom?: string, siriRideScheduledStartTimeTo?: string, gtfsStopLatGreaterOrEqual?: number, gtfsStopLatLowerOrEqual?: number, gtfsStopLonGreaterOrEqual?: number, gtfsStopLonLowerOrEqual?: number, gtfsDateFrom?: string, gtfsDateTo?: string, orderBy?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/siri_ride_stops/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (getCount !== undefined) {
                localVarQueryParameter['get_count'] = getCount;
            }

            if (siriStopIds !== undefined) {
                localVarQueryParameter['siri_stop_ids'] = siriStopIds;
            }

            if (siriRideIds !== undefined) {
                localVarQueryParameter['siri_ride_ids'] = siriRideIds;
            }

            if (siriVehicleLocationLonGreaterOrEqual !== undefined) {
                localVarQueryParameter['siri_vehicle_location__lon__greater_or_equal'] = siriVehicleLocationLonGreaterOrEqual;
            }

            if (siriVehicleLocationLonLowerOrEqual !== undefined) {
                localVarQueryParameter['siri_vehicle_location__lon__lower_or_equal'] = siriVehicleLocationLonLowerOrEqual;
            }

            if (siriVehicleLocationLatGreaterOrEqual !== undefined) {
                localVarQueryParameter['siri_vehicle_location__lat__greater_or_equal'] = siriVehicleLocationLatGreaterOrEqual;
            }

            if (siriVehicleLocationLatLowerOrEqual !== undefined) {
                localVarQueryParameter['siri_vehicle_location__lat__lower_or_equal'] = siriVehicleLocationLatLowerOrEqual;
            }

            if (siriVehicleLocationRecordedAtTimeFrom !== undefined) {
                localVarQueryParameter['siri_vehicle_location__recorded_at_time_from'] = (siriVehicleLocationRecordedAtTimeFrom as any instanceof Date) ?
                    (siriVehicleLocationRecordedAtTimeFrom as any).toISOString() :
                    siriVehicleLocationRecordedAtTimeFrom;
            }

            if (siriVehicleLocationRecordedAtTimeTo !== undefined) {
                localVarQueryParameter['siri_vehicle_location__recorded_at_time_to'] = (siriVehicleLocationRecordedAtTimeTo as any instanceof Date) ?
                    (siriVehicleLocationRecordedAtTimeTo as any).toISOString() :
                    siriVehicleLocationRecordedAtTimeTo;
            }

            if (siriRideScheduledStartTimeFrom !== undefined) {
                localVarQueryParameter['siri_ride__scheduled_start_time_from'] = (siriRideScheduledStartTimeFrom as any instanceof Date) ?
                    (siriRideScheduledStartTimeFrom as any).toISOString() :
                    siriRideScheduledStartTimeFrom;
            }

            if (siriRideScheduledStartTimeTo !== undefined) {
                localVarQueryParameter['siri_ride__scheduled_start_time_to'] = (siriRideScheduledStartTimeTo as any instanceof Date) ?
                    (siriRideScheduledStartTimeTo as any).toISOString() :
                    siriRideScheduledStartTimeTo;
            }

            if (gtfsStopLatGreaterOrEqual !== undefined) {
                localVarQueryParameter['gtfs_stop__lat__greater_or_equal'] = gtfsStopLatGreaterOrEqual;
            }

            if (gtfsStopLatLowerOrEqual !== undefined) {
                localVarQueryParameter['gtfs_stop__lat__lower_or_equal'] = gtfsStopLatLowerOrEqual;
            }

            if (gtfsStopLonGreaterOrEqual !== undefined) {
                localVarQueryParameter['gtfs_stop__lon__greater_or_equal'] = gtfsStopLonGreaterOrEqual;
            }

            if (gtfsStopLonLowerOrEqual !== undefined) {
                localVarQueryParameter['gtfs_stop__lon__lower_or_equal'] = gtfsStopLonLowerOrEqual;
            }

            if (gtfsDateFrom !== undefined) {
                localVarQueryParameter['gtfs_date_from'] = (gtfsDateFrom as any instanceof Date) ?
                    (gtfsDateFrom as any).toISOString().substring(0,10) :
                    gtfsDateFrom;
            }

            if (gtfsDateTo !== undefined) {
                localVarQueryParameter['gtfs_date_to'] = (gtfsDateTo as any instanceof Date) ?
                    (gtfsDateTo as any).toISOString().substring(0,10) :
                    gtfsDateTo;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List of siri rides.
         * @summary List 
         * @param {number} [limit] Limit the number of returned results. If not specified will limit to 100 results. To get more results, you can either use the offset param, alternatively - set the limit to -1 and use http streaming with compatible json streaming decoder to get all results, this method can fetch up to a maximum of 500000 results.
         * @param {number} [offset] Item number to start returning results from. Use in combination with limit for pagination, alternatively, don\&#39;t set offset, set limit to -1 and use http streaming with compatible json streaming decoder to get all results up to a maximum of 500000 results.
         * @param {boolean} [getCount] Set to \&quot;true\&quot; to only get the total number of results for given filters. limit/offset/order parameters will be ignored.
         * @param {string} [gtfsRouteDateFrom]   Filter by related gtfs route\&#39;s date. Only return items which have a date after or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
         * @param {string} [gtfsRouteDateTo]   Filter by related gtfs route\&#39;s date. Only return items which have a date before or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
         * @param {string} [gtfsRouteLineRefs]   Filter by related gtfs route\&#39;s line ref. Comma-separated list of values.
         * @param {string} [gtfsRouteOperatorRefs] Agency identifier. To get it, first query gtfs_agencies.  Filter by related gtfs route\&#39;s operator ref. Comma-separated list of values.  Example: 3 for Eged
         * @param {string} [gtfsRouteRouteShortName] Line number.  Filter by related gtfs route\&#39;s route short name. Only return items which exactly match given string.  Example: 480
         * @param {string} [gtfsRouteRouteLongNameContains]   Filter by related gtfs route\&#39;s route long name. Only return items which contain given string.
         * @param {string} [gtfsRouteRouteMkt]   Filter by related gtfs route\&#39;s route mkt. Only return items which exactly match given string.
         * @param {string} [gtfsRouteRouteDirection]   Filter by related gtfs route\&#39;s route direction. Only return items which exactly match given string.
         * @param {string} [gtfsRouteRouteAlternative]   Filter by related gtfs route\&#39;s route alternative. Only return items which exactly match given string.
         * @param {string} [gtfsRouteAgencyName]   Filter by related gtfs route\&#39;s agency name. Only return items which exactly match given string.
         * @param {string} [gtfsRouteRouteType]   Filter by related gtfs route\&#39;s route type. Only return items which exactly match given string.
         * @param {number} [gtfsRideGtfsRouteId]   Filter by related gtfs ride\&#39;s gtfs route id. Only return items which exactly match given string.
         * @param {string} [gtfsRideJourneyRefPrefix]   Filter by related gtfs ride\&#39;s journey ref prefix. Only return items which start with given string.
         * @param {string} [gtfsRideStartTimeFrom]   Filter by related gtfs ride\&#39;s start time from. Only return items which have date/time after or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
         * @param {string} [gtfsRideStartTimeTo]   Filter by related gtfs ride\&#39;s start time to. Only return items which have date/time before or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
         * @param {string} [siriRouteIds]   Filter by siri route ids. Comma-separated list of values.
         * @param {string} [siriRouteLineRefs]   Filter by siri route line refs. Comma-separated list of values.
         * @param {string} [siriRouteOperatorRefs]   Filter by siri route operator refs. Comma-separated list of values.
         * @param {string} [journeyRefPrefix]   Filter by journey ref prefix. Only return items which start with given string.
         * @param {string} [journeyRefs]   Filter by journey ref. Comma-separated list of values.
         * @param {string} [vehicleRefs]   Filter by vehicle ref. Comma-separated list of values.
         * @param {string} [scheduledStartTimeFrom]   Filter by scheduled start time. Only return items which have date/time after or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
         * @param {string} [scheduledStartTimeTo]   Filter by scheduled start time. Only return items which have date/time before or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
         * @param {string} [orderBy] Order of the results. Comma-separated list of fields and direction. e.g. \&quot;field1 asc,field2 desc\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSiriRidesListGet: async (limit?: number, offset?: number, getCount?: boolean, gtfsRouteDateFrom?: string, gtfsRouteDateTo?: string, gtfsRouteLineRefs?: string, gtfsRouteOperatorRefs?: string, gtfsRouteRouteShortName?: string, gtfsRouteRouteLongNameContains?: string, gtfsRouteRouteMkt?: string, gtfsRouteRouteDirection?: string, gtfsRouteRouteAlternative?: string, gtfsRouteAgencyName?: string, gtfsRouteRouteType?: string, gtfsRideGtfsRouteId?: number, gtfsRideJourneyRefPrefix?: string, gtfsRideStartTimeFrom?: string, gtfsRideStartTimeTo?: string, siriRouteIds?: string, siriRouteLineRefs?: string, siriRouteOperatorRefs?: string, journeyRefPrefix?: string, journeyRefs?: string, vehicleRefs?: string, scheduledStartTimeFrom?: string, scheduledStartTimeTo?: string, orderBy?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/siri_rides/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (getCount !== undefined) {
                localVarQueryParameter['get_count'] = getCount;
            }

            if (gtfsRouteDateFrom !== undefined) {
                localVarQueryParameter['gtfs_route__date_from'] = (gtfsRouteDateFrom as any instanceof Date) ?
                    (gtfsRouteDateFrom as any).toISOString().substring(0,10) :
                    gtfsRouteDateFrom;
            }

            if (gtfsRouteDateTo !== undefined) {
                localVarQueryParameter['gtfs_route__date_to'] = (gtfsRouteDateTo as any instanceof Date) ?
                    (gtfsRouteDateTo as any).toISOString().substring(0,10) :
                    gtfsRouteDateTo;
            }

            if (gtfsRouteLineRefs !== undefined) {
                localVarQueryParameter['gtfs_route__line_refs'] = gtfsRouteLineRefs;
            }

            if (gtfsRouteOperatorRefs !== undefined) {
                localVarQueryParameter['gtfs_route__operator_refs'] = gtfsRouteOperatorRefs;
            }

            if (gtfsRouteRouteShortName !== undefined) {
                localVarQueryParameter['gtfs_route__route_short_name'] = gtfsRouteRouteShortName;
            }

            if (gtfsRouteRouteLongNameContains !== undefined) {
                localVarQueryParameter['gtfs_route__route_long_name_contains'] = gtfsRouteRouteLongNameContains;
            }

            if (gtfsRouteRouteMkt !== undefined) {
                localVarQueryParameter['gtfs_route__route_mkt'] = gtfsRouteRouteMkt;
            }

            if (gtfsRouteRouteDirection !== undefined) {
                localVarQueryParameter['gtfs_route__route_direction'] = gtfsRouteRouteDirection;
            }

            if (gtfsRouteRouteAlternative !== undefined) {
                localVarQueryParameter['gtfs_route__route_alternative'] = gtfsRouteRouteAlternative;
            }

            if (gtfsRouteAgencyName !== undefined) {
                localVarQueryParameter['gtfs_route__agency_name'] = gtfsRouteAgencyName;
            }

            if (gtfsRouteRouteType !== undefined) {
                localVarQueryParameter['gtfs_route__route_type'] = gtfsRouteRouteType;
            }

            if (gtfsRideGtfsRouteId !== undefined) {
                localVarQueryParameter['gtfs_ride__gtfs_route_id'] = gtfsRideGtfsRouteId;
            }

            if (gtfsRideJourneyRefPrefix !== undefined) {
                localVarQueryParameter['gtfs_ride__journey_ref_prefix'] = gtfsRideJourneyRefPrefix;
            }

            if (gtfsRideStartTimeFrom !== undefined) {
                localVarQueryParameter['gtfs_ride__start_time_from'] = (gtfsRideStartTimeFrom as any instanceof Date) ?
                    (gtfsRideStartTimeFrom as any).toISOString() :
                    gtfsRideStartTimeFrom;
            }

            if (gtfsRideStartTimeTo !== undefined) {
                localVarQueryParameter['gtfs_ride__start_time_to'] = (gtfsRideStartTimeTo as any instanceof Date) ?
                    (gtfsRideStartTimeTo as any).toISOString() :
                    gtfsRideStartTimeTo;
            }

            if (siriRouteIds !== undefined) {
                localVarQueryParameter['siri_route_ids'] = siriRouteIds;
            }

            if (siriRouteLineRefs !== undefined) {
                localVarQueryParameter['siri_route__line_refs'] = siriRouteLineRefs;
            }

            if (siriRouteOperatorRefs !== undefined) {
                localVarQueryParameter['siri_route__operator_refs'] = siriRouteOperatorRefs;
            }

            if (journeyRefPrefix !== undefined) {
                localVarQueryParameter['journey_ref_prefix'] = journeyRefPrefix;
            }

            if (journeyRefs !== undefined) {
                localVarQueryParameter['journey_refs'] = journeyRefs;
            }

            if (vehicleRefs !== undefined) {
                localVarQueryParameter['vehicle_refs'] = vehicleRefs;
            }

            if (scheduledStartTimeFrom !== undefined) {
                localVarQueryParameter['scheduled_start_time_from'] = (scheduledStartTimeFrom as any instanceof Date) ?
                    (scheduledStartTimeFrom as any).toISOString() :
                    scheduledStartTimeFrom;
            }

            if (scheduledStartTimeTo !== undefined) {
                localVarQueryParameter['scheduled_start_time_to'] = (scheduledStartTimeTo as any instanceof Date) ?
                    (scheduledStartTimeTo as any).toISOString() :
                    scheduledStartTimeTo;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List of siri routes.
         * @summary List 
         * @param {number} [limit] Limit the number of returned results. If not specified will limit to 100 results. To get more results, you can either use the offset param, alternatively - set the limit to -1 and use http streaming with compatible json streaming decoder to get all results, this method can fetch up to a maximum of 500000 results.
         * @param {number} [offset] Item number to start returning results from. Use in combination with limit for pagination, alternatively, don\&#39;t set offset, set limit to -1 and use http streaming with compatible json streaming decoder to get all results up to a maximum of 500000 results.
         * @param {boolean} [getCount] Set to \&quot;true\&quot; to only get the total number of results for given filters. limit/offset/order parameters will be ignored.
         * @param {string} [lineRefs]   Filter by line ref. Comma-separated list of values.
         * @param {string} [operatorRefs]   Filter by operator ref. Comma-separated list of values.
         * @param {string} [orderBy] Order of the results. Comma-separated list of fields and direction. e.g. \&quot;field1 asc,field2 desc\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSiriRoutesListGet: async (limit?: number, offset?: number, getCount?: boolean, lineRefs?: string, operatorRefs?: string, orderBy?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/siri_routes/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (getCount !== undefined) {
                localVarQueryParameter['get_count'] = getCount;
            }

            if (lineRefs !== undefined) {
                localVarQueryParameter['line_refs'] = lineRefs;
            }

            if (operatorRefs !== undefined) {
                localVarQueryParameter['operator_refs'] = operatorRefs;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List of siri snapshots.
         * @summary List 
         * @param {number} [limit] Limit the number of returned results. If not specified will limit to 100 results. To get more results, you can either use the offset param, alternatively - set the limit to -1 and use http streaming with compatible json streaming decoder to get all results, this method can fetch up to a maximum of 500000 results.
         * @param {number} [offset] Item number to start returning results from. Use in combination with limit for pagination, alternatively, don\&#39;t set offset, set limit to -1 and use http streaming with compatible json streaming decoder to get all results up to a maximum of 500000 results.
         * @param {boolean} [getCount] Set to \&quot;true\&quot; to only get the total number of results for given filters. limit/offset/order parameters will be ignored.
         * @param {string} [snapshotIdPrefix]   Filter by snapshot id prefix. Only return items which start with given string.
         * @param {string} [orderBy] Order of the results. Comma-separated list of fields and direction. e.g. \&quot;field1 asc,field2 desc\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSiriSnapshotsListGet: async (limit?: number, offset?: number, getCount?: boolean, snapshotIdPrefix?: string, orderBy?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/siri_snapshots/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (getCount !== undefined) {
                localVarQueryParameter['get_count'] = getCount;
            }

            if (snapshotIdPrefix !== undefined) {
                localVarQueryParameter['snapshot_id_prefix'] = snapshotIdPrefix;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List of siri stops.
         * @summary List 
         * @param {number} [limit] Limit the number of returned results. If not specified will limit to 100 results. To get more results, you can either use the offset param, alternatively - set the limit to -1 and use http streaming with compatible json streaming decoder to get all results, this method can fetch up to a maximum of 500000 results.
         * @param {number} [offset] Item number to start returning results from. Use in combination with limit for pagination, alternatively, don\&#39;t set offset, set limit to -1 and use http streaming with compatible json streaming decoder to get all results up to a maximum of 500000 results.
         * @param {boolean} [getCount] Set to \&quot;true\&quot; to only get the total number of results for given filters. limit/offset/order parameters will be ignored.
         * @param {string} [codes]   Filter by stop code. Comma-separated list of values.
         * @param {string} [orderBy] Order of the results. Comma-separated list of fields and direction. e.g. \&quot;field1 asc,field2 desc\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSiriStopsListGet: async (limit?: number, offset?: number, getCount?: boolean, codes?: string, orderBy?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/siri_stops/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (getCount !== undefined) {
                localVarQueryParameter['get_count'] = getCount;
            }

            if (codes !== undefined) {
                localVarQueryParameter['codes'] = codes;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List of siri vehicle locations.
         * @summary List 
         * @param {number} [limit] Limit the number of returned results. If not specified will limit to 100 results. To get more results, you can either use the offset param, alternatively - set the limit to -1 and use http streaming with compatible json streaming decoder to get all results, this method can fetch up to a maximum of 500000 results.
         * @param {number} [offset] Item number to start returning results from. Use in combination with limit for pagination, alternatively, don\&#39;t set offset, set limit to -1 and use http streaming with compatible json streaming decoder to get all results up to a maximum of 500000 results.
         * @param {boolean} [getCount] Set to \&quot;true\&quot; to only get the total number of results for given filters. limit/offset/order parameters will be ignored.
         * @param {string} [siriVehicleLocationIds]   Filter by siri vehicle location id. Comma-separated list of values.
         * @param {string} [siriSnapshotIds]   Filter by siri snapshot id. Comma-separated list of values.
         * @param {string} [siriRideStopIds]   Filter by siri ride stop id. Comma-separated list of values.
         * @param {string} [recordedAtTimeFrom]   Filter by recorded at time. Only return items which have date/time after or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
         * @param {string} [recordedAtTimeTo]   Filter by recorded at time. Only return items which have date/time before or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
         * @param {number} [lonGreaterOrEqual]   Filter by lon. Only return items which have a numeric value greater than or equal to given value  Example: 34.808
         * @param {number} [lonLowerOrEqual]   Filter by lon. Only return items which have a numeric value lower than or equal to given value  Example: 34.808
         * @param {number} [latGreaterOrEqual]   Filter by lat. Only return items which have a numeric value greater than or equal to given value  Example: 31.961
         * @param {number} [latLowerOrEqual]   Filter by lat. Only return items which have a numeric value lower than or equal to given value  Example: 31.961
         * @param {string} [orderBy] Order of the results. Comma-separated list of fields and direction. e.g. \&quot;field1 asc,field2 desc\&quot;.
         * @param {string} [siriRoutesLineRef]   Filter by siri route line ref. Only return items which exactly match given string.
         * @param {string} [siriRideVehicleRef]   Filter by siri ride vehicle ref. Only return items which exactly match given string.
         * @param {string} [siriRoutesOperatorRef]   Filter by siri route operator ref. Only return items which exactly match given string.
         * @param {string} [siriRidesSchedualedStartTimeFrom]   Filter by siri ride scheduled start time. Only return items which have date/time after or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
         * @param {string} [siriRidesSchedualedStartTimeTo]   Filter by siri ride scheduled start time. Only return items which have date/time before or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
         * @param {string} [siriRidesIds]   Filter by siri ride id. Comma-separated list of values.
         * @param {string} [siriRoutesIds]   Filter by siri route id. Comma-separated list of values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSiriVehicleLocationsListGet: async (limit?: number, offset?: number, getCount?: boolean, siriVehicleLocationIds?: string, siriSnapshotIds?: string, siriRideStopIds?: string, recordedAtTimeFrom?: string, recordedAtTimeTo?: string, lonGreaterOrEqual?: number, lonLowerOrEqual?: number, latGreaterOrEqual?: number, latLowerOrEqual?: number, orderBy?: string, siriRoutesLineRef?: string, siriRideVehicleRef?: string, siriRoutesOperatorRef?: string, siriRidesSchedualedStartTimeFrom?: string, siriRidesSchedualedStartTimeTo?: string, siriRidesIds?: string, siriRoutesIds?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/siri_vehicle_locations/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (getCount !== undefined) {
                localVarQueryParameter['get_count'] = getCount;
            }

            if (siriVehicleLocationIds !== undefined) {
                localVarQueryParameter['siri_vehicle_location_ids'] = siriVehicleLocationIds;
            }

            if (siriSnapshotIds !== undefined) {
                localVarQueryParameter['siri_snapshot_ids'] = siriSnapshotIds;
            }

            if (siriRideStopIds !== undefined) {
                localVarQueryParameter['siri_ride_stop_ids'] = siriRideStopIds;
            }

            if (recordedAtTimeFrom !== undefined) {
                localVarQueryParameter['recorded_at_time_from'] = (recordedAtTimeFrom as any instanceof Date) ?
                    (recordedAtTimeFrom as any).toISOString() :
                    recordedAtTimeFrom;
            }

            if (recordedAtTimeTo !== undefined) {
                localVarQueryParameter['recorded_at_time_to'] = (recordedAtTimeTo as any instanceof Date) ?
                    (recordedAtTimeTo as any).toISOString() :
                    recordedAtTimeTo;
            }

            if (lonGreaterOrEqual !== undefined) {
                localVarQueryParameter['lon__greater_or_equal'] = lonGreaterOrEqual;
            }

            if (lonLowerOrEqual !== undefined) {
                localVarQueryParameter['lon__lower_or_equal'] = lonLowerOrEqual;
            }

            if (latGreaterOrEqual !== undefined) {
                localVarQueryParameter['lat__greater_or_equal'] = latGreaterOrEqual;
            }

            if (latLowerOrEqual !== undefined) {
                localVarQueryParameter['lat__lower_or_equal'] = latLowerOrEqual;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (siriRoutesLineRef !== undefined) {
                localVarQueryParameter['siri_routes__line_ref'] = siriRoutesLineRef;
            }

            if (siriRideVehicleRef !== undefined) {
                localVarQueryParameter['siri_ride__vehicle_ref'] = siriRideVehicleRef;
            }

            if (siriRoutesOperatorRef !== undefined) {
                localVarQueryParameter['siri_routes__operator_ref'] = siriRoutesOperatorRef;
            }

            if (siriRidesSchedualedStartTimeFrom !== undefined) {
                localVarQueryParameter['siri_rides__schedualed_start_time_from'] = (siriRidesSchedualedStartTimeFrom as any instanceof Date) ?
                    (siriRidesSchedualedStartTimeFrom as any).toISOString() :
                    siriRidesSchedualedStartTimeFrom;
            }

            if (siriRidesSchedualedStartTimeTo !== undefined) {
                localVarQueryParameter['siri_rides__schedualed_start_time_to'] = (siriRidesSchedualedStartTimeTo as any instanceof Date) ?
                    (siriRidesSchedualedStartTimeTo as any).toISOString() :
                    siriRidesSchedualedStartTimeTo;
            }

            if (siriRidesIds !== undefined) {
                localVarQueryParameter['siri_rides__ids'] = siriRidesIds;
            }

            if (siriRoutesIds !== undefined) {
                localVarQueryParameter['siri_routes__ids'] = siriRoutesIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SiriApi - functional programming interface
 * @export
 */
export const SiriApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SiriApiAxiosParamCreator(configuration)
    return {
        /**
         * Return a single siri ride stop based on id
         * @summary Get 
         * @param {number} id siri ride stop id to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSiriRideStopsGetGet(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SiriRideStopPydanticModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSiriRideStopsGetGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SiriApi.getSiriRideStopsGetGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return a single siri ride based on id
         * @summary Get 
         * @param {number} id siri ride id to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSiriRidesGetGet(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SiriRidePydanticModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSiriRidesGetGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SiriApi.getSiriRidesGetGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return a single siri route based on id
         * @summary Get 
         * @param {number} id siri route id to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSiriRoutesGetGet(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SiriRoutePydanticModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSiriRoutesGetGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SiriApi.getSiriRoutesGetGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return a single siri snapshot based on id
         * @summary Get 
         * @param {number} id siri snapshot id to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSiriSnapshotsGetGet(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SiriSnapshotPydanticModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSiriSnapshotsGetGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SiriApi.getSiriSnapshotsGetGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return a single siri stop based on id
         * @summary Get 
         * @param {number} id siri stop id to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSiriStopsGetGet(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SiriStopPydanticModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSiriStopsGetGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SiriApi.getSiriStopsGetGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return a single siri vehicle location based on id
         * @summary Get 
         * @param {number} id siri vehicle location id to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSiriVehicleLocationsGetGet(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SiriVehicleLocationPydanticModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSiriVehicleLocationsGetGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SiriApi.getSiriVehicleLocationsGetGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List of siri ride stops.
         * @summary List 
         * @param {number} [limit] Limit the number of returned results. If not specified will limit to 100 results. To get more results, you can either use the offset param, alternatively - set the limit to -1 and use http streaming with compatible json streaming decoder to get all results, this method can fetch up to a maximum of 500000 results.
         * @param {number} [offset] Item number to start returning results from. Use in combination with limit for pagination, alternatively, don\&#39;t set offset, set limit to -1 and use http streaming with compatible json streaming decoder to get all results up to a maximum of 500000 results.
         * @param {boolean} [getCount] Set to \&quot;true\&quot; to only get the total number of results for given filters. limit/offset/order parameters will be ignored.
         * @param {string} [siriStopIds]   Filter by siri stop id. Comma-separated list of values.
         * @param {string} [siriRideIds]   Filter by siri ride id. Comma-separated list of values.
         * @param {number} [siriVehicleLocationLonGreaterOrEqual]   Filter by siri vehicle location lon. Only return items which have a numeric value greater than or equal to given value  Example: 34.808
         * @param {number} [siriVehicleLocationLonLowerOrEqual]   Filter by siri vehicle location lon. Only return items which have a numeric value lower than or equal to given value  Example: 34.808
         * @param {number} [siriVehicleLocationLatGreaterOrEqual]   Filter by siri vehicle location lat. Only return items which have a numeric value greater than or equal to given value  Example: 31.961
         * @param {number} [siriVehicleLocationLatLowerOrEqual]   Filter by siri vehicle location lat. Only return items which have a numeric value lower than or equal to given value  Example: 31.961
         * @param {string} [siriVehicleLocationRecordedAtTimeFrom]   Filter by siri vehicle location recorded at time. Only return items which have date/time after or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
         * @param {string} [siriVehicleLocationRecordedAtTimeTo]   Filter by siri vehicle location recorded at time. Only return items which have date/time before or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
         * @param {string} [siriRideScheduledStartTimeFrom]   Filter by siri ride scheduled start time. Only return items which have date/time after or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
         * @param {string} [siriRideScheduledStartTimeTo]   Filter by siri ride scheduled start time. Only return items which have date/time before or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
         * @param {number} [gtfsStopLatGreaterOrEqual]   Filter by gtfs stop lat. Only return items which have a numeric value greater than or equal to given value  Example: 31.961
         * @param {number} [gtfsStopLatLowerOrEqual]   Filter by gtfs stop lat. Only return items which have a numeric value lower than or equal to given value  Example: 31.961
         * @param {number} [gtfsStopLonGreaterOrEqual]   Filter by gtfs stop lon. Only return items which have a numeric value greater than or equal to given value  Example: 34.808
         * @param {number} [gtfsStopLonLowerOrEqual]   Filter by gtfs stop lon. Only return items which have a numeric value lower than or equal to given value  Example: 34.808
         * @param {string} [gtfsDateFrom] filter all gtfs related records on this date  Filter by gtfs date. Only return items which have a date after or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
         * @param {string} [gtfsDateTo] filter all gtfs related records on this date  Filter by gtfs date. Only return items which have a date before or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
         * @param {string} [orderBy] Order of the results. Comma-separated list of fields and direction. e.g. \&quot;field1 asc,field2 desc\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSiriRideStopsListGet(limit?: number, offset?: number, getCount?: boolean, siriStopIds?: string, siriRideIds?: string, siriVehicleLocationLonGreaterOrEqual?: number, siriVehicleLocationLonLowerOrEqual?: number, siriVehicleLocationLatGreaterOrEqual?: number, siriVehicleLocationLatLowerOrEqual?: number, siriVehicleLocationRecordedAtTimeFrom?: string, siriVehicleLocationRecordedAtTimeTo?: string, siriRideScheduledStartTimeFrom?: string, siriRideScheduledStartTimeTo?: string, gtfsStopLatGreaterOrEqual?: number, gtfsStopLatLowerOrEqual?: number, gtfsStopLonGreaterOrEqual?: number, gtfsStopLonLowerOrEqual?: number, gtfsDateFrom?: string, gtfsDateTo?: string, orderBy?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SiriRideStopWithRelatedPydanticModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSiriRideStopsListGet(limit, offset, getCount, siriStopIds, siriRideIds, siriVehicleLocationLonGreaterOrEqual, siriVehicleLocationLonLowerOrEqual, siriVehicleLocationLatGreaterOrEqual, siriVehicleLocationLatLowerOrEqual, siriVehicleLocationRecordedAtTimeFrom, siriVehicleLocationRecordedAtTimeTo, siriRideScheduledStartTimeFrom, siriRideScheduledStartTimeTo, gtfsStopLatGreaterOrEqual, gtfsStopLatLowerOrEqual, gtfsStopLonGreaterOrEqual, gtfsStopLonLowerOrEqual, gtfsDateFrom, gtfsDateTo, orderBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SiriApi.listSiriRideStopsListGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List of siri rides.
         * @summary List 
         * @param {number} [limit] Limit the number of returned results. If not specified will limit to 100 results. To get more results, you can either use the offset param, alternatively - set the limit to -1 and use http streaming with compatible json streaming decoder to get all results, this method can fetch up to a maximum of 500000 results.
         * @param {number} [offset] Item number to start returning results from. Use in combination with limit for pagination, alternatively, don\&#39;t set offset, set limit to -1 and use http streaming with compatible json streaming decoder to get all results up to a maximum of 500000 results.
         * @param {boolean} [getCount] Set to \&quot;true\&quot; to only get the total number of results for given filters. limit/offset/order parameters will be ignored.
         * @param {string} [gtfsRouteDateFrom]   Filter by related gtfs route\&#39;s date. Only return items which have a date after or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
         * @param {string} [gtfsRouteDateTo]   Filter by related gtfs route\&#39;s date. Only return items which have a date before or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
         * @param {string} [gtfsRouteLineRefs]   Filter by related gtfs route\&#39;s line ref. Comma-separated list of values.
         * @param {string} [gtfsRouteOperatorRefs] Agency identifier. To get it, first query gtfs_agencies.  Filter by related gtfs route\&#39;s operator ref. Comma-separated list of values.  Example: 3 for Eged
         * @param {string} [gtfsRouteRouteShortName] Line number.  Filter by related gtfs route\&#39;s route short name. Only return items which exactly match given string.  Example: 480
         * @param {string} [gtfsRouteRouteLongNameContains]   Filter by related gtfs route\&#39;s route long name. Only return items which contain given string.
         * @param {string} [gtfsRouteRouteMkt]   Filter by related gtfs route\&#39;s route mkt. Only return items which exactly match given string.
         * @param {string} [gtfsRouteRouteDirection]   Filter by related gtfs route\&#39;s route direction. Only return items which exactly match given string.
         * @param {string} [gtfsRouteRouteAlternative]   Filter by related gtfs route\&#39;s route alternative. Only return items which exactly match given string.
         * @param {string} [gtfsRouteAgencyName]   Filter by related gtfs route\&#39;s agency name. Only return items which exactly match given string.
         * @param {string} [gtfsRouteRouteType]   Filter by related gtfs route\&#39;s route type. Only return items which exactly match given string.
         * @param {number} [gtfsRideGtfsRouteId]   Filter by related gtfs ride\&#39;s gtfs route id. Only return items which exactly match given string.
         * @param {string} [gtfsRideJourneyRefPrefix]   Filter by related gtfs ride\&#39;s journey ref prefix. Only return items which start with given string.
         * @param {string} [gtfsRideStartTimeFrom]   Filter by related gtfs ride\&#39;s start time from. Only return items which have date/time after or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
         * @param {string} [gtfsRideStartTimeTo]   Filter by related gtfs ride\&#39;s start time to. Only return items which have date/time before or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
         * @param {string} [siriRouteIds]   Filter by siri route ids. Comma-separated list of values.
         * @param {string} [siriRouteLineRefs]   Filter by siri route line refs. Comma-separated list of values.
         * @param {string} [siriRouteOperatorRefs]   Filter by siri route operator refs. Comma-separated list of values.
         * @param {string} [journeyRefPrefix]   Filter by journey ref prefix. Only return items which start with given string.
         * @param {string} [journeyRefs]   Filter by journey ref. Comma-separated list of values.
         * @param {string} [vehicleRefs]   Filter by vehicle ref. Comma-separated list of values.
         * @param {string} [scheduledStartTimeFrom]   Filter by scheduled start time. Only return items which have date/time after or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
         * @param {string} [scheduledStartTimeTo]   Filter by scheduled start time. Only return items which have date/time before or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
         * @param {string} [orderBy] Order of the results. Comma-separated list of fields and direction. e.g. \&quot;field1 asc,field2 desc\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSiriRidesListGet(limit?: number, offset?: number, getCount?: boolean, gtfsRouteDateFrom?: string, gtfsRouteDateTo?: string, gtfsRouteLineRefs?: string, gtfsRouteOperatorRefs?: string, gtfsRouteRouteShortName?: string, gtfsRouteRouteLongNameContains?: string, gtfsRouteRouteMkt?: string, gtfsRouteRouteDirection?: string, gtfsRouteRouteAlternative?: string, gtfsRouteAgencyName?: string, gtfsRouteRouteType?: string, gtfsRideGtfsRouteId?: number, gtfsRideJourneyRefPrefix?: string, gtfsRideStartTimeFrom?: string, gtfsRideStartTimeTo?: string, siriRouteIds?: string, siriRouteLineRefs?: string, siriRouteOperatorRefs?: string, journeyRefPrefix?: string, journeyRefs?: string, vehicleRefs?: string, scheduledStartTimeFrom?: string, scheduledStartTimeTo?: string, orderBy?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SiriRideWithRelatedPydanticModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSiriRidesListGet(limit, offset, getCount, gtfsRouteDateFrom, gtfsRouteDateTo, gtfsRouteLineRefs, gtfsRouteOperatorRefs, gtfsRouteRouteShortName, gtfsRouteRouteLongNameContains, gtfsRouteRouteMkt, gtfsRouteRouteDirection, gtfsRouteRouteAlternative, gtfsRouteAgencyName, gtfsRouteRouteType, gtfsRideGtfsRouteId, gtfsRideJourneyRefPrefix, gtfsRideStartTimeFrom, gtfsRideStartTimeTo, siriRouteIds, siriRouteLineRefs, siriRouteOperatorRefs, journeyRefPrefix, journeyRefs, vehicleRefs, scheduledStartTimeFrom, scheduledStartTimeTo, orderBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SiriApi.listSiriRidesListGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List of siri routes.
         * @summary List 
         * @param {number} [limit] Limit the number of returned results. If not specified will limit to 100 results. To get more results, you can either use the offset param, alternatively - set the limit to -1 and use http streaming with compatible json streaming decoder to get all results, this method can fetch up to a maximum of 500000 results.
         * @param {number} [offset] Item number to start returning results from. Use in combination with limit for pagination, alternatively, don\&#39;t set offset, set limit to -1 and use http streaming with compatible json streaming decoder to get all results up to a maximum of 500000 results.
         * @param {boolean} [getCount] Set to \&quot;true\&quot; to only get the total number of results for given filters. limit/offset/order parameters will be ignored.
         * @param {string} [lineRefs]   Filter by line ref. Comma-separated list of values.
         * @param {string} [operatorRefs]   Filter by operator ref. Comma-separated list of values.
         * @param {string} [orderBy] Order of the results. Comma-separated list of fields and direction. e.g. \&quot;field1 asc,field2 desc\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSiriRoutesListGet(limit?: number, offset?: number, getCount?: boolean, lineRefs?: string, operatorRefs?: string, orderBy?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SiriRoutePydanticModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSiriRoutesListGet(limit, offset, getCount, lineRefs, operatorRefs, orderBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SiriApi.listSiriRoutesListGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List of siri snapshots.
         * @summary List 
         * @param {number} [limit] Limit the number of returned results. If not specified will limit to 100 results. To get more results, you can either use the offset param, alternatively - set the limit to -1 and use http streaming with compatible json streaming decoder to get all results, this method can fetch up to a maximum of 500000 results.
         * @param {number} [offset] Item number to start returning results from. Use in combination with limit for pagination, alternatively, don\&#39;t set offset, set limit to -1 and use http streaming with compatible json streaming decoder to get all results up to a maximum of 500000 results.
         * @param {boolean} [getCount] Set to \&quot;true\&quot; to only get the total number of results for given filters. limit/offset/order parameters will be ignored.
         * @param {string} [snapshotIdPrefix]   Filter by snapshot id prefix. Only return items which start with given string.
         * @param {string} [orderBy] Order of the results. Comma-separated list of fields and direction. e.g. \&quot;field1 asc,field2 desc\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSiriSnapshotsListGet(limit?: number, offset?: number, getCount?: boolean, snapshotIdPrefix?: string, orderBy?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SiriSnapshotPydanticModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSiriSnapshotsListGet(limit, offset, getCount, snapshotIdPrefix, orderBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SiriApi.listSiriSnapshotsListGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List of siri stops.
         * @summary List 
         * @param {number} [limit] Limit the number of returned results. If not specified will limit to 100 results. To get more results, you can either use the offset param, alternatively - set the limit to -1 and use http streaming with compatible json streaming decoder to get all results, this method can fetch up to a maximum of 500000 results.
         * @param {number} [offset] Item number to start returning results from. Use in combination with limit for pagination, alternatively, don\&#39;t set offset, set limit to -1 and use http streaming with compatible json streaming decoder to get all results up to a maximum of 500000 results.
         * @param {boolean} [getCount] Set to \&quot;true\&quot; to only get the total number of results for given filters. limit/offset/order parameters will be ignored.
         * @param {string} [codes]   Filter by stop code. Comma-separated list of values.
         * @param {string} [orderBy] Order of the results. Comma-separated list of fields and direction. e.g. \&quot;field1 asc,field2 desc\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSiriStopsListGet(limit?: number, offset?: number, getCount?: boolean, codes?: string, orderBy?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SiriStopPydanticModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSiriStopsListGet(limit, offset, getCount, codes, orderBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SiriApi.listSiriStopsListGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List of siri vehicle locations.
         * @summary List 
         * @param {number} [limit] Limit the number of returned results. If not specified will limit to 100 results. To get more results, you can either use the offset param, alternatively - set the limit to -1 and use http streaming with compatible json streaming decoder to get all results, this method can fetch up to a maximum of 500000 results.
         * @param {number} [offset] Item number to start returning results from. Use in combination with limit for pagination, alternatively, don\&#39;t set offset, set limit to -1 and use http streaming with compatible json streaming decoder to get all results up to a maximum of 500000 results.
         * @param {boolean} [getCount] Set to \&quot;true\&quot; to only get the total number of results for given filters. limit/offset/order parameters will be ignored.
         * @param {string} [siriVehicleLocationIds]   Filter by siri vehicle location id. Comma-separated list of values.
         * @param {string} [siriSnapshotIds]   Filter by siri snapshot id. Comma-separated list of values.
         * @param {string} [siriRideStopIds]   Filter by siri ride stop id. Comma-separated list of values.
         * @param {string} [recordedAtTimeFrom]   Filter by recorded at time. Only return items which have date/time after or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
         * @param {string} [recordedAtTimeTo]   Filter by recorded at time. Only return items which have date/time before or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
         * @param {number} [lonGreaterOrEqual]   Filter by lon. Only return items which have a numeric value greater than or equal to given value  Example: 34.808
         * @param {number} [lonLowerOrEqual]   Filter by lon. Only return items which have a numeric value lower than or equal to given value  Example: 34.808
         * @param {number} [latGreaterOrEqual]   Filter by lat. Only return items which have a numeric value greater than or equal to given value  Example: 31.961
         * @param {number} [latLowerOrEqual]   Filter by lat. Only return items which have a numeric value lower than or equal to given value  Example: 31.961
         * @param {string} [orderBy] Order of the results. Comma-separated list of fields and direction. e.g. \&quot;field1 asc,field2 desc\&quot;.
         * @param {string} [siriRoutesLineRef]   Filter by siri route line ref. Only return items which exactly match given string.
         * @param {string} [siriRideVehicleRef]   Filter by siri ride vehicle ref. Only return items which exactly match given string.
         * @param {string} [siriRoutesOperatorRef]   Filter by siri route operator ref. Only return items which exactly match given string.
         * @param {string} [siriRidesSchedualedStartTimeFrom]   Filter by siri ride scheduled start time. Only return items which have date/time after or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
         * @param {string} [siriRidesSchedualedStartTimeTo]   Filter by siri ride scheduled start time. Only return items which have date/time before or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
         * @param {string} [siriRidesIds]   Filter by siri ride id. Comma-separated list of values.
         * @param {string} [siriRoutesIds]   Filter by siri route id. Comma-separated list of values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSiriVehicleLocationsListGet(limit?: number, offset?: number, getCount?: boolean, siriVehicleLocationIds?: string, siriSnapshotIds?: string, siriRideStopIds?: string, recordedAtTimeFrom?: string, recordedAtTimeTo?: string, lonGreaterOrEqual?: number, lonLowerOrEqual?: number, latGreaterOrEqual?: number, latLowerOrEqual?: number, orderBy?: string, siriRoutesLineRef?: string, siriRideVehicleRef?: string, siriRoutesOperatorRef?: string, siriRidesSchedualedStartTimeFrom?: string, siriRidesSchedualedStartTimeTo?: string, siriRidesIds?: string, siriRoutesIds?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SiriVehicleLocationWithRelatedPydanticModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSiriVehicleLocationsListGet(limit, offset, getCount, siriVehicleLocationIds, siriSnapshotIds, siriRideStopIds, recordedAtTimeFrom, recordedAtTimeTo, lonGreaterOrEqual, lonLowerOrEqual, latGreaterOrEqual, latLowerOrEqual, orderBy, siriRoutesLineRef, siriRideVehicleRef, siriRoutesOperatorRef, siriRidesSchedualedStartTimeFrom, siriRidesSchedualedStartTimeTo, siriRidesIds, siriRoutesIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SiriApi.listSiriVehicleLocationsListGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SiriApi - factory interface
 * @export
 */
export const SiriApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SiriApiFp(configuration)
    return {
        /**
         * Return a single siri ride stop based on id
         * @summary Get 
         * @param {number} id siri ride stop id to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSiriRideStopsGetGet(id: number, options?: RawAxiosRequestConfig): AxiosPromise<SiriRideStopPydanticModel> {
            return localVarFp.getSiriRideStopsGetGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Return a single siri ride based on id
         * @summary Get 
         * @param {number} id siri ride id to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSiriRidesGetGet(id: number, options?: RawAxiosRequestConfig): AxiosPromise<SiriRidePydanticModel> {
            return localVarFp.getSiriRidesGetGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Return a single siri route based on id
         * @summary Get 
         * @param {number} id siri route id to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSiriRoutesGetGet(id: number, options?: RawAxiosRequestConfig): AxiosPromise<SiriRoutePydanticModel> {
            return localVarFp.getSiriRoutesGetGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Return a single siri snapshot based on id
         * @summary Get 
         * @param {number} id siri snapshot id to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSiriSnapshotsGetGet(id: number, options?: RawAxiosRequestConfig): AxiosPromise<SiriSnapshotPydanticModel> {
            return localVarFp.getSiriSnapshotsGetGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Return a single siri stop based on id
         * @summary Get 
         * @param {number} id siri stop id to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSiriStopsGetGet(id: number, options?: RawAxiosRequestConfig): AxiosPromise<SiriStopPydanticModel> {
            return localVarFp.getSiriStopsGetGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Return a single siri vehicle location based on id
         * @summary Get 
         * @param {number} id siri vehicle location id to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSiriVehicleLocationsGetGet(id: number, options?: RawAxiosRequestConfig): AxiosPromise<SiriVehicleLocationPydanticModel> {
            return localVarFp.getSiriVehicleLocationsGetGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * List of siri ride stops.
         * @summary List 
         * @param {number} [limit] Limit the number of returned results. If not specified will limit to 100 results. To get more results, you can either use the offset param, alternatively - set the limit to -1 and use http streaming with compatible json streaming decoder to get all results, this method can fetch up to a maximum of 500000 results.
         * @param {number} [offset] Item number to start returning results from. Use in combination with limit for pagination, alternatively, don\&#39;t set offset, set limit to -1 and use http streaming with compatible json streaming decoder to get all results up to a maximum of 500000 results.
         * @param {boolean} [getCount] Set to \&quot;true\&quot; to only get the total number of results for given filters. limit/offset/order parameters will be ignored.
         * @param {string} [siriStopIds]   Filter by siri stop id. Comma-separated list of values.
         * @param {string} [siriRideIds]   Filter by siri ride id. Comma-separated list of values.
         * @param {number} [siriVehicleLocationLonGreaterOrEqual]   Filter by siri vehicle location lon. Only return items which have a numeric value greater than or equal to given value  Example: 34.808
         * @param {number} [siriVehicleLocationLonLowerOrEqual]   Filter by siri vehicle location lon. Only return items which have a numeric value lower than or equal to given value  Example: 34.808
         * @param {number} [siriVehicleLocationLatGreaterOrEqual]   Filter by siri vehicle location lat. Only return items which have a numeric value greater than or equal to given value  Example: 31.961
         * @param {number} [siriVehicleLocationLatLowerOrEqual]   Filter by siri vehicle location lat. Only return items which have a numeric value lower than or equal to given value  Example: 31.961
         * @param {string} [siriVehicleLocationRecordedAtTimeFrom]   Filter by siri vehicle location recorded at time. Only return items which have date/time after or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
         * @param {string} [siriVehicleLocationRecordedAtTimeTo]   Filter by siri vehicle location recorded at time. Only return items which have date/time before or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
         * @param {string} [siriRideScheduledStartTimeFrom]   Filter by siri ride scheduled start time. Only return items which have date/time after or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
         * @param {string} [siriRideScheduledStartTimeTo]   Filter by siri ride scheduled start time. Only return items which have date/time before or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
         * @param {number} [gtfsStopLatGreaterOrEqual]   Filter by gtfs stop lat. Only return items which have a numeric value greater than or equal to given value  Example: 31.961
         * @param {number} [gtfsStopLatLowerOrEqual]   Filter by gtfs stop lat. Only return items which have a numeric value lower than or equal to given value  Example: 31.961
         * @param {number} [gtfsStopLonGreaterOrEqual]   Filter by gtfs stop lon. Only return items which have a numeric value greater than or equal to given value  Example: 34.808
         * @param {number} [gtfsStopLonLowerOrEqual]   Filter by gtfs stop lon. Only return items which have a numeric value lower than or equal to given value  Example: 34.808
         * @param {string} [gtfsDateFrom] filter all gtfs related records on this date  Filter by gtfs date. Only return items which have a date after or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
         * @param {string} [gtfsDateTo] filter all gtfs related records on this date  Filter by gtfs date. Only return items which have a date before or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
         * @param {string} [orderBy] Order of the results. Comma-separated list of fields and direction. e.g. \&quot;field1 asc,field2 desc\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSiriRideStopsListGet(limit?: number, offset?: number, getCount?: boolean, siriStopIds?: string, siriRideIds?: string, siriVehicleLocationLonGreaterOrEqual?: number, siriVehicleLocationLonLowerOrEqual?: number, siriVehicleLocationLatGreaterOrEqual?: number, siriVehicleLocationLatLowerOrEqual?: number, siriVehicleLocationRecordedAtTimeFrom?: string, siriVehicleLocationRecordedAtTimeTo?: string, siriRideScheduledStartTimeFrom?: string, siriRideScheduledStartTimeTo?: string, gtfsStopLatGreaterOrEqual?: number, gtfsStopLatLowerOrEqual?: number, gtfsStopLonGreaterOrEqual?: number, gtfsStopLonLowerOrEqual?: number, gtfsDateFrom?: string, gtfsDateTo?: string, orderBy?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<SiriRideStopWithRelatedPydanticModel>> {
            return localVarFp.listSiriRideStopsListGet(limit, offset, getCount, siriStopIds, siriRideIds, siriVehicleLocationLonGreaterOrEqual, siriVehicleLocationLonLowerOrEqual, siriVehicleLocationLatGreaterOrEqual, siriVehicleLocationLatLowerOrEqual, siriVehicleLocationRecordedAtTimeFrom, siriVehicleLocationRecordedAtTimeTo, siriRideScheduledStartTimeFrom, siriRideScheduledStartTimeTo, gtfsStopLatGreaterOrEqual, gtfsStopLatLowerOrEqual, gtfsStopLonGreaterOrEqual, gtfsStopLonLowerOrEqual, gtfsDateFrom, gtfsDateTo, orderBy, options).then((request) => request(axios, basePath));
        },
        /**
         * List of siri rides.
         * @summary List 
         * @param {number} [limit] Limit the number of returned results. If not specified will limit to 100 results. To get more results, you can either use the offset param, alternatively - set the limit to -1 and use http streaming with compatible json streaming decoder to get all results, this method can fetch up to a maximum of 500000 results.
         * @param {number} [offset] Item number to start returning results from. Use in combination with limit for pagination, alternatively, don\&#39;t set offset, set limit to -1 and use http streaming with compatible json streaming decoder to get all results up to a maximum of 500000 results.
         * @param {boolean} [getCount] Set to \&quot;true\&quot; to only get the total number of results for given filters. limit/offset/order parameters will be ignored.
         * @param {string} [gtfsRouteDateFrom]   Filter by related gtfs route\&#39;s date. Only return items which have a date after or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
         * @param {string} [gtfsRouteDateTo]   Filter by related gtfs route\&#39;s date. Only return items which have a date before or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
         * @param {string} [gtfsRouteLineRefs]   Filter by related gtfs route\&#39;s line ref. Comma-separated list of values.
         * @param {string} [gtfsRouteOperatorRefs] Agency identifier. To get it, first query gtfs_agencies.  Filter by related gtfs route\&#39;s operator ref. Comma-separated list of values.  Example: 3 for Eged
         * @param {string} [gtfsRouteRouteShortName] Line number.  Filter by related gtfs route\&#39;s route short name. Only return items which exactly match given string.  Example: 480
         * @param {string} [gtfsRouteRouteLongNameContains]   Filter by related gtfs route\&#39;s route long name. Only return items which contain given string.
         * @param {string} [gtfsRouteRouteMkt]   Filter by related gtfs route\&#39;s route mkt. Only return items which exactly match given string.
         * @param {string} [gtfsRouteRouteDirection]   Filter by related gtfs route\&#39;s route direction. Only return items which exactly match given string.
         * @param {string} [gtfsRouteRouteAlternative]   Filter by related gtfs route\&#39;s route alternative. Only return items which exactly match given string.
         * @param {string} [gtfsRouteAgencyName]   Filter by related gtfs route\&#39;s agency name. Only return items which exactly match given string.
         * @param {string} [gtfsRouteRouteType]   Filter by related gtfs route\&#39;s route type. Only return items which exactly match given string.
         * @param {number} [gtfsRideGtfsRouteId]   Filter by related gtfs ride\&#39;s gtfs route id. Only return items which exactly match given string.
         * @param {string} [gtfsRideJourneyRefPrefix]   Filter by related gtfs ride\&#39;s journey ref prefix. Only return items which start with given string.
         * @param {string} [gtfsRideStartTimeFrom]   Filter by related gtfs ride\&#39;s start time from. Only return items which have date/time after or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
         * @param {string} [gtfsRideStartTimeTo]   Filter by related gtfs ride\&#39;s start time to. Only return items which have date/time before or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
         * @param {string} [siriRouteIds]   Filter by siri route ids. Comma-separated list of values.
         * @param {string} [siriRouteLineRefs]   Filter by siri route line refs. Comma-separated list of values.
         * @param {string} [siriRouteOperatorRefs]   Filter by siri route operator refs. Comma-separated list of values.
         * @param {string} [journeyRefPrefix]   Filter by journey ref prefix. Only return items which start with given string.
         * @param {string} [journeyRefs]   Filter by journey ref. Comma-separated list of values.
         * @param {string} [vehicleRefs]   Filter by vehicle ref. Comma-separated list of values.
         * @param {string} [scheduledStartTimeFrom]   Filter by scheduled start time. Only return items which have date/time after or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
         * @param {string} [scheduledStartTimeTo]   Filter by scheduled start time. Only return items which have date/time before or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
         * @param {string} [orderBy] Order of the results. Comma-separated list of fields and direction. e.g. \&quot;field1 asc,field2 desc\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSiriRidesListGet(limit?: number, offset?: number, getCount?: boolean, gtfsRouteDateFrom?: string, gtfsRouteDateTo?: string, gtfsRouteLineRefs?: string, gtfsRouteOperatorRefs?: string, gtfsRouteRouteShortName?: string, gtfsRouteRouteLongNameContains?: string, gtfsRouteRouteMkt?: string, gtfsRouteRouteDirection?: string, gtfsRouteRouteAlternative?: string, gtfsRouteAgencyName?: string, gtfsRouteRouteType?: string, gtfsRideGtfsRouteId?: number, gtfsRideJourneyRefPrefix?: string, gtfsRideStartTimeFrom?: string, gtfsRideStartTimeTo?: string, siriRouteIds?: string, siriRouteLineRefs?: string, siriRouteOperatorRefs?: string, journeyRefPrefix?: string, journeyRefs?: string, vehicleRefs?: string, scheduledStartTimeFrom?: string, scheduledStartTimeTo?: string, orderBy?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<SiriRideWithRelatedPydanticModel>> {
            return localVarFp.listSiriRidesListGet(limit, offset, getCount, gtfsRouteDateFrom, gtfsRouteDateTo, gtfsRouteLineRefs, gtfsRouteOperatorRefs, gtfsRouteRouteShortName, gtfsRouteRouteLongNameContains, gtfsRouteRouteMkt, gtfsRouteRouteDirection, gtfsRouteRouteAlternative, gtfsRouteAgencyName, gtfsRouteRouteType, gtfsRideGtfsRouteId, gtfsRideJourneyRefPrefix, gtfsRideStartTimeFrom, gtfsRideStartTimeTo, siriRouteIds, siriRouteLineRefs, siriRouteOperatorRefs, journeyRefPrefix, journeyRefs, vehicleRefs, scheduledStartTimeFrom, scheduledStartTimeTo, orderBy, options).then((request) => request(axios, basePath));
        },
        /**
         * List of siri routes.
         * @summary List 
         * @param {number} [limit] Limit the number of returned results. If not specified will limit to 100 results. To get more results, you can either use the offset param, alternatively - set the limit to -1 and use http streaming with compatible json streaming decoder to get all results, this method can fetch up to a maximum of 500000 results.
         * @param {number} [offset] Item number to start returning results from. Use in combination with limit for pagination, alternatively, don\&#39;t set offset, set limit to -1 and use http streaming with compatible json streaming decoder to get all results up to a maximum of 500000 results.
         * @param {boolean} [getCount] Set to \&quot;true\&quot; to only get the total number of results for given filters. limit/offset/order parameters will be ignored.
         * @param {string} [lineRefs]   Filter by line ref. Comma-separated list of values.
         * @param {string} [operatorRefs]   Filter by operator ref. Comma-separated list of values.
         * @param {string} [orderBy] Order of the results. Comma-separated list of fields and direction. e.g. \&quot;field1 asc,field2 desc\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSiriRoutesListGet(limit?: number, offset?: number, getCount?: boolean, lineRefs?: string, operatorRefs?: string, orderBy?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<SiriRoutePydanticModel>> {
            return localVarFp.listSiriRoutesListGet(limit, offset, getCount, lineRefs, operatorRefs, orderBy, options).then((request) => request(axios, basePath));
        },
        /**
         * List of siri snapshots.
         * @summary List 
         * @param {number} [limit] Limit the number of returned results. If not specified will limit to 100 results. To get more results, you can either use the offset param, alternatively - set the limit to -1 and use http streaming with compatible json streaming decoder to get all results, this method can fetch up to a maximum of 500000 results.
         * @param {number} [offset] Item number to start returning results from. Use in combination with limit for pagination, alternatively, don\&#39;t set offset, set limit to -1 and use http streaming with compatible json streaming decoder to get all results up to a maximum of 500000 results.
         * @param {boolean} [getCount] Set to \&quot;true\&quot; to only get the total number of results for given filters. limit/offset/order parameters will be ignored.
         * @param {string} [snapshotIdPrefix]   Filter by snapshot id prefix. Only return items which start with given string.
         * @param {string} [orderBy] Order of the results. Comma-separated list of fields and direction. e.g. \&quot;field1 asc,field2 desc\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSiriSnapshotsListGet(limit?: number, offset?: number, getCount?: boolean, snapshotIdPrefix?: string, orderBy?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<SiriSnapshotPydanticModel>> {
            return localVarFp.listSiriSnapshotsListGet(limit, offset, getCount, snapshotIdPrefix, orderBy, options).then((request) => request(axios, basePath));
        },
        /**
         * List of siri stops.
         * @summary List 
         * @param {number} [limit] Limit the number of returned results. If not specified will limit to 100 results. To get more results, you can either use the offset param, alternatively - set the limit to -1 and use http streaming with compatible json streaming decoder to get all results, this method can fetch up to a maximum of 500000 results.
         * @param {number} [offset] Item number to start returning results from. Use in combination with limit for pagination, alternatively, don\&#39;t set offset, set limit to -1 and use http streaming with compatible json streaming decoder to get all results up to a maximum of 500000 results.
         * @param {boolean} [getCount] Set to \&quot;true\&quot; to only get the total number of results for given filters. limit/offset/order parameters will be ignored.
         * @param {string} [codes]   Filter by stop code. Comma-separated list of values.
         * @param {string} [orderBy] Order of the results. Comma-separated list of fields and direction. e.g. \&quot;field1 asc,field2 desc\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSiriStopsListGet(limit?: number, offset?: number, getCount?: boolean, codes?: string, orderBy?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<SiriStopPydanticModel>> {
            return localVarFp.listSiriStopsListGet(limit, offset, getCount, codes, orderBy, options).then((request) => request(axios, basePath));
        },
        /**
         * List of siri vehicle locations.
         * @summary List 
         * @param {number} [limit] Limit the number of returned results. If not specified will limit to 100 results. To get more results, you can either use the offset param, alternatively - set the limit to -1 and use http streaming with compatible json streaming decoder to get all results, this method can fetch up to a maximum of 500000 results.
         * @param {number} [offset] Item number to start returning results from. Use in combination with limit for pagination, alternatively, don\&#39;t set offset, set limit to -1 and use http streaming with compatible json streaming decoder to get all results up to a maximum of 500000 results.
         * @param {boolean} [getCount] Set to \&quot;true\&quot; to only get the total number of results for given filters. limit/offset/order parameters will be ignored.
         * @param {string} [siriVehicleLocationIds]   Filter by siri vehicle location id. Comma-separated list of values.
         * @param {string} [siriSnapshotIds]   Filter by siri snapshot id. Comma-separated list of values.
         * @param {string} [siriRideStopIds]   Filter by siri ride stop id. Comma-separated list of values.
         * @param {string} [recordedAtTimeFrom]   Filter by recorded at time. Only return items which have date/time after or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
         * @param {string} [recordedAtTimeTo]   Filter by recorded at time. Only return items which have date/time before or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
         * @param {number} [lonGreaterOrEqual]   Filter by lon. Only return items which have a numeric value greater than or equal to given value  Example: 34.808
         * @param {number} [lonLowerOrEqual]   Filter by lon. Only return items which have a numeric value lower than or equal to given value  Example: 34.808
         * @param {number} [latGreaterOrEqual]   Filter by lat. Only return items which have a numeric value greater than or equal to given value  Example: 31.961
         * @param {number} [latLowerOrEqual]   Filter by lat. Only return items which have a numeric value lower than or equal to given value  Example: 31.961
         * @param {string} [orderBy] Order of the results. Comma-separated list of fields and direction. e.g. \&quot;field1 asc,field2 desc\&quot;.
         * @param {string} [siriRoutesLineRef]   Filter by siri route line ref. Only return items which exactly match given string.
         * @param {string} [siriRideVehicleRef]   Filter by siri ride vehicle ref. Only return items which exactly match given string.
         * @param {string} [siriRoutesOperatorRef]   Filter by siri route operator ref. Only return items which exactly match given string.
         * @param {string} [siriRidesSchedualedStartTimeFrom]   Filter by siri ride scheduled start time. Only return items which have date/time after or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
         * @param {string} [siriRidesSchedualedStartTimeTo]   Filter by siri ride scheduled start time. Only return items which have date/time before or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
         * @param {string} [siriRidesIds]   Filter by siri ride id. Comma-separated list of values.
         * @param {string} [siriRoutesIds]   Filter by siri route id. Comma-separated list of values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSiriVehicleLocationsListGet(limit?: number, offset?: number, getCount?: boolean, siriVehicleLocationIds?: string, siriSnapshotIds?: string, siriRideStopIds?: string, recordedAtTimeFrom?: string, recordedAtTimeTo?: string, lonGreaterOrEqual?: number, lonLowerOrEqual?: number, latGreaterOrEqual?: number, latLowerOrEqual?: number, orderBy?: string, siriRoutesLineRef?: string, siriRideVehicleRef?: string, siriRoutesOperatorRef?: string, siriRidesSchedualedStartTimeFrom?: string, siriRidesSchedualedStartTimeTo?: string, siriRidesIds?: string, siriRoutesIds?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<SiriVehicleLocationWithRelatedPydanticModel>> {
            return localVarFp.listSiriVehicleLocationsListGet(limit, offset, getCount, siriVehicleLocationIds, siriSnapshotIds, siriRideStopIds, recordedAtTimeFrom, recordedAtTimeTo, lonGreaterOrEqual, lonLowerOrEqual, latGreaterOrEqual, latLowerOrEqual, orderBy, siriRoutesLineRef, siriRideVehicleRef, siriRoutesOperatorRef, siriRidesSchedualedStartTimeFrom, siriRidesSchedualedStartTimeTo, siriRidesIds, siriRoutesIds, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SiriApi - object-oriented interface
 * @export
 * @class SiriApi
 * @extends {BaseAPI}
 */
export class SiriApi extends BaseAPI {
    /**
     * Return a single siri ride stop based on id
     * @summary Get 
     * @param {number} id siri ride stop id to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiriApi
     */
    public getSiriRideStopsGetGet(id: number, options?: RawAxiosRequestConfig) {
        return SiriApiFp(this.configuration).getSiriRideStopsGetGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return a single siri ride based on id
     * @summary Get 
     * @param {number} id siri ride id to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiriApi
     */
    public getSiriRidesGetGet(id: number, options?: RawAxiosRequestConfig) {
        return SiriApiFp(this.configuration).getSiriRidesGetGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return a single siri route based on id
     * @summary Get 
     * @param {number} id siri route id to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiriApi
     */
    public getSiriRoutesGetGet(id: number, options?: RawAxiosRequestConfig) {
        return SiriApiFp(this.configuration).getSiriRoutesGetGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return a single siri snapshot based on id
     * @summary Get 
     * @param {number} id siri snapshot id to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiriApi
     */
    public getSiriSnapshotsGetGet(id: number, options?: RawAxiosRequestConfig) {
        return SiriApiFp(this.configuration).getSiriSnapshotsGetGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return a single siri stop based on id
     * @summary Get 
     * @param {number} id siri stop id to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiriApi
     */
    public getSiriStopsGetGet(id: number, options?: RawAxiosRequestConfig) {
        return SiriApiFp(this.configuration).getSiriStopsGetGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return a single siri vehicle location based on id
     * @summary Get 
     * @param {number} id siri vehicle location id to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiriApi
     */
    public getSiriVehicleLocationsGetGet(id: number, options?: RawAxiosRequestConfig) {
        return SiriApiFp(this.configuration).getSiriVehicleLocationsGetGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List of siri ride stops.
     * @summary List 
     * @param {number} [limit] Limit the number of returned results. If not specified will limit to 100 results. To get more results, you can either use the offset param, alternatively - set the limit to -1 and use http streaming with compatible json streaming decoder to get all results, this method can fetch up to a maximum of 500000 results.
     * @param {number} [offset] Item number to start returning results from. Use in combination with limit for pagination, alternatively, don\&#39;t set offset, set limit to -1 and use http streaming with compatible json streaming decoder to get all results up to a maximum of 500000 results.
     * @param {boolean} [getCount] Set to \&quot;true\&quot; to only get the total number of results for given filters. limit/offset/order parameters will be ignored.
     * @param {string} [siriStopIds]   Filter by siri stop id. Comma-separated list of values.
     * @param {string} [siriRideIds]   Filter by siri ride id. Comma-separated list of values.
     * @param {number} [siriVehicleLocationLonGreaterOrEqual]   Filter by siri vehicle location lon. Only return items which have a numeric value greater than or equal to given value  Example: 34.808
     * @param {number} [siriVehicleLocationLonLowerOrEqual]   Filter by siri vehicle location lon. Only return items which have a numeric value lower than or equal to given value  Example: 34.808
     * @param {number} [siriVehicleLocationLatGreaterOrEqual]   Filter by siri vehicle location lat. Only return items which have a numeric value greater than or equal to given value  Example: 31.961
     * @param {number} [siriVehicleLocationLatLowerOrEqual]   Filter by siri vehicle location lat. Only return items which have a numeric value lower than or equal to given value  Example: 31.961
     * @param {string} [siriVehicleLocationRecordedAtTimeFrom]   Filter by siri vehicle location recorded at time. Only return items which have date/time after or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
     * @param {string} [siriVehicleLocationRecordedAtTimeTo]   Filter by siri vehicle location recorded at time. Only return items which have date/time before or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
     * @param {string} [siriRideScheduledStartTimeFrom]   Filter by siri ride scheduled start time. Only return items which have date/time after or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
     * @param {string} [siriRideScheduledStartTimeTo]   Filter by siri ride scheduled start time. Only return items which have date/time before or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
     * @param {number} [gtfsStopLatGreaterOrEqual]   Filter by gtfs stop lat. Only return items which have a numeric value greater than or equal to given value  Example: 31.961
     * @param {number} [gtfsStopLatLowerOrEqual]   Filter by gtfs stop lat. Only return items which have a numeric value lower than or equal to given value  Example: 31.961
     * @param {number} [gtfsStopLonGreaterOrEqual]   Filter by gtfs stop lon. Only return items which have a numeric value greater than or equal to given value  Example: 34.808
     * @param {number} [gtfsStopLonLowerOrEqual]   Filter by gtfs stop lon. Only return items which have a numeric value lower than or equal to given value  Example: 34.808
     * @param {string} [gtfsDateFrom] filter all gtfs related records on this date  Filter by gtfs date. Only return items which have a date after or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
     * @param {string} [gtfsDateTo] filter all gtfs related records on this date  Filter by gtfs date. Only return items which have a date before or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
     * @param {string} [orderBy] Order of the results. Comma-separated list of fields and direction. e.g. \&quot;field1 asc,field2 desc\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiriApi
     */
    public listSiriRideStopsListGet(limit?: number, offset?: number, getCount?: boolean, siriStopIds?: string, siriRideIds?: string, siriVehicleLocationLonGreaterOrEqual?: number, siriVehicleLocationLonLowerOrEqual?: number, siriVehicleLocationLatGreaterOrEqual?: number, siriVehicleLocationLatLowerOrEqual?: number, siriVehicleLocationRecordedAtTimeFrom?: string, siriVehicleLocationRecordedAtTimeTo?: string, siriRideScheduledStartTimeFrom?: string, siriRideScheduledStartTimeTo?: string, gtfsStopLatGreaterOrEqual?: number, gtfsStopLatLowerOrEqual?: number, gtfsStopLonGreaterOrEqual?: number, gtfsStopLonLowerOrEqual?: number, gtfsDateFrom?: string, gtfsDateTo?: string, orderBy?: string, options?: RawAxiosRequestConfig) {
        return SiriApiFp(this.configuration).listSiriRideStopsListGet(limit, offset, getCount, siriStopIds, siriRideIds, siriVehicleLocationLonGreaterOrEqual, siriVehicleLocationLonLowerOrEqual, siriVehicleLocationLatGreaterOrEqual, siriVehicleLocationLatLowerOrEqual, siriVehicleLocationRecordedAtTimeFrom, siriVehicleLocationRecordedAtTimeTo, siriRideScheduledStartTimeFrom, siriRideScheduledStartTimeTo, gtfsStopLatGreaterOrEqual, gtfsStopLatLowerOrEqual, gtfsStopLonGreaterOrEqual, gtfsStopLonLowerOrEqual, gtfsDateFrom, gtfsDateTo, orderBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List of siri rides.
     * @summary List 
     * @param {number} [limit] Limit the number of returned results. If not specified will limit to 100 results. To get more results, you can either use the offset param, alternatively - set the limit to -1 and use http streaming with compatible json streaming decoder to get all results, this method can fetch up to a maximum of 500000 results.
     * @param {number} [offset] Item number to start returning results from. Use in combination with limit for pagination, alternatively, don\&#39;t set offset, set limit to -1 and use http streaming with compatible json streaming decoder to get all results up to a maximum of 500000 results.
     * @param {boolean} [getCount] Set to \&quot;true\&quot; to only get the total number of results for given filters. limit/offset/order parameters will be ignored.
     * @param {string} [gtfsRouteDateFrom]   Filter by related gtfs route\&#39;s date. Only return items which have a date after or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
     * @param {string} [gtfsRouteDateTo]   Filter by related gtfs route\&#39;s date. Only return items which have a date before or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
     * @param {string} [gtfsRouteLineRefs]   Filter by related gtfs route\&#39;s line ref. Comma-separated list of values.
     * @param {string} [gtfsRouteOperatorRefs] Agency identifier. To get it, first query gtfs_agencies.  Filter by related gtfs route\&#39;s operator ref. Comma-separated list of values.  Example: 3 for Eged
     * @param {string} [gtfsRouteRouteShortName] Line number.  Filter by related gtfs route\&#39;s route short name. Only return items which exactly match given string.  Example: 480
     * @param {string} [gtfsRouteRouteLongNameContains]   Filter by related gtfs route\&#39;s route long name. Only return items which contain given string.
     * @param {string} [gtfsRouteRouteMkt]   Filter by related gtfs route\&#39;s route mkt. Only return items which exactly match given string.
     * @param {string} [gtfsRouteRouteDirection]   Filter by related gtfs route\&#39;s route direction. Only return items which exactly match given string.
     * @param {string} [gtfsRouteRouteAlternative]   Filter by related gtfs route\&#39;s route alternative. Only return items which exactly match given string.
     * @param {string} [gtfsRouteAgencyName]   Filter by related gtfs route\&#39;s agency name. Only return items which exactly match given string.
     * @param {string} [gtfsRouteRouteType]   Filter by related gtfs route\&#39;s route type. Only return items which exactly match given string.
     * @param {number} [gtfsRideGtfsRouteId]   Filter by related gtfs ride\&#39;s gtfs route id. Only return items which exactly match given string.
     * @param {string} [gtfsRideJourneyRefPrefix]   Filter by related gtfs ride\&#39;s journey ref prefix. Only return items which start with given string.
     * @param {string} [gtfsRideStartTimeFrom]   Filter by related gtfs ride\&#39;s start time from. Only return items which have date/time after or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
     * @param {string} [gtfsRideStartTimeTo]   Filter by related gtfs ride\&#39;s start time to. Only return items which have date/time before or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
     * @param {string} [siriRouteIds]   Filter by siri route ids. Comma-separated list of values.
     * @param {string} [siriRouteLineRefs]   Filter by siri route line refs. Comma-separated list of values.
     * @param {string} [siriRouteOperatorRefs]   Filter by siri route operator refs. Comma-separated list of values.
     * @param {string} [journeyRefPrefix]   Filter by journey ref prefix. Only return items which start with given string.
     * @param {string} [journeyRefs]   Filter by journey ref. Comma-separated list of values.
     * @param {string} [vehicleRefs]   Filter by vehicle ref. Comma-separated list of values.
     * @param {string} [scheduledStartTimeFrom]   Filter by scheduled start time. Only return items which have date/time after or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
     * @param {string} [scheduledStartTimeTo]   Filter by scheduled start time. Only return items which have date/time before or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
     * @param {string} [orderBy] Order of the results. Comma-separated list of fields and direction. e.g. \&quot;field1 asc,field2 desc\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiriApi
     */
    public listSiriRidesListGet(limit?: number, offset?: number, getCount?: boolean, gtfsRouteDateFrom?: string, gtfsRouteDateTo?: string, gtfsRouteLineRefs?: string, gtfsRouteOperatorRefs?: string, gtfsRouteRouteShortName?: string, gtfsRouteRouteLongNameContains?: string, gtfsRouteRouteMkt?: string, gtfsRouteRouteDirection?: string, gtfsRouteRouteAlternative?: string, gtfsRouteAgencyName?: string, gtfsRouteRouteType?: string, gtfsRideGtfsRouteId?: number, gtfsRideJourneyRefPrefix?: string, gtfsRideStartTimeFrom?: string, gtfsRideStartTimeTo?: string, siriRouteIds?: string, siriRouteLineRefs?: string, siriRouteOperatorRefs?: string, journeyRefPrefix?: string, journeyRefs?: string, vehicleRefs?: string, scheduledStartTimeFrom?: string, scheduledStartTimeTo?: string, orderBy?: string, options?: RawAxiosRequestConfig) {
        return SiriApiFp(this.configuration).listSiriRidesListGet(limit, offset, getCount, gtfsRouteDateFrom, gtfsRouteDateTo, gtfsRouteLineRefs, gtfsRouteOperatorRefs, gtfsRouteRouteShortName, gtfsRouteRouteLongNameContains, gtfsRouteRouteMkt, gtfsRouteRouteDirection, gtfsRouteRouteAlternative, gtfsRouteAgencyName, gtfsRouteRouteType, gtfsRideGtfsRouteId, gtfsRideJourneyRefPrefix, gtfsRideStartTimeFrom, gtfsRideStartTimeTo, siriRouteIds, siriRouteLineRefs, siriRouteOperatorRefs, journeyRefPrefix, journeyRefs, vehicleRefs, scheduledStartTimeFrom, scheduledStartTimeTo, orderBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List of siri routes.
     * @summary List 
     * @param {number} [limit] Limit the number of returned results. If not specified will limit to 100 results. To get more results, you can either use the offset param, alternatively - set the limit to -1 and use http streaming with compatible json streaming decoder to get all results, this method can fetch up to a maximum of 500000 results.
     * @param {number} [offset] Item number to start returning results from. Use in combination with limit for pagination, alternatively, don\&#39;t set offset, set limit to -1 and use http streaming with compatible json streaming decoder to get all results up to a maximum of 500000 results.
     * @param {boolean} [getCount] Set to \&quot;true\&quot; to only get the total number of results for given filters. limit/offset/order parameters will be ignored.
     * @param {string} [lineRefs]   Filter by line ref. Comma-separated list of values.
     * @param {string} [operatorRefs]   Filter by operator ref. Comma-separated list of values.
     * @param {string} [orderBy] Order of the results. Comma-separated list of fields and direction. e.g. \&quot;field1 asc,field2 desc\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiriApi
     */
    public listSiriRoutesListGet(limit?: number, offset?: number, getCount?: boolean, lineRefs?: string, operatorRefs?: string, orderBy?: string, options?: RawAxiosRequestConfig) {
        return SiriApiFp(this.configuration).listSiriRoutesListGet(limit, offset, getCount, lineRefs, operatorRefs, orderBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List of siri snapshots.
     * @summary List 
     * @param {number} [limit] Limit the number of returned results. If not specified will limit to 100 results. To get more results, you can either use the offset param, alternatively - set the limit to -1 and use http streaming with compatible json streaming decoder to get all results, this method can fetch up to a maximum of 500000 results.
     * @param {number} [offset] Item number to start returning results from. Use in combination with limit for pagination, alternatively, don\&#39;t set offset, set limit to -1 and use http streaming with compatible json streaming decoder to get all results up to a maximum of 500000 results.
     * @param {boolean} [getCount] Set to \&quot;true\&quot; to only get the total number of results for given filters. limit/offset/order parameters will be ignored.
     * @param {string} [snapshotIdPrefix]   Filter by snapshot id prefix. Only return items which start with given string.
     * @param {string} [orderBy] Order of the results. Comma-separated list of fields and direction. e.g. \&quot;field1 asc,field2 desc\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiriApi
     */
    public listSiriSnapshotsListGet(limit?: number, offset?: number, getCount?: boolean, snapshotIdPrefix?: string, orderBy?: string, options?: RawAxiosRequestConfig) {
        return SiriApiFp(this.configuration).listSiriSnapshotsListGet(limit, offset, getCount, snapshotIdPrefix, orderBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List of siri stops.
     * @summary List 
     * @param {number} [limit] Limit the number of returned results. If not specified will limit to 100 results. To get more results, you can either use the offset param, alternatively - set the limit to -1 and use http streaming with compatible json streaming decoder to get all results, this method can fetch up to a maximum of 500000 results.
     * @param {number} [offset] Item number to start returning results from. Use in combination with limit for pagination, alternatively, don\&#39;t set offset, set limit to -1 and use http streaming with compatible json streaming decoder to get all results up to a maximum of 500000 results.
     * @param {boolean} [getCount] Set to \&quot;true\&quot; to only get the total number of results for given filters. limit/offset/order parameters will be ignored.
     * @param {string} [codes]   Filter by stop code. Comma-separated list of values.
     * @param {string} [orderBy] Order of the results. Comma-separated list of fields and direction. e.g. \&quot;field1 asc,field2 desc\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiriApi
     */
    public listSiriStopsListGet(limit?: number, offset?: number, getCount?: boolean, codes?: string, orderBy?: string, options?: RawAxiosRequestConfig) {
        return SiriApiFp(this.configuration).listSiriStopsListGet(limit, offset, getCount, codes, orderBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List of siri vehicle locations.
     * @summary List 
     * @param {number} [limit] Limit the number of returned results. If not specified will limit to 100 results. To get more results, you can either use the offset param, alternatively - set the limit to -1 and use http streaming with compatible json streaming decoder to get all results, this method can fetch up to a maximum of 500000 results.
     * @param {number} [offset] Item number to start returning results from. Use in combination with limit for pagination, alternatively, don\&#39;t set offset, set limit to -1 and use http streaming with compatible json streaming decoder to get all results up to a maximum of 500000 results.
     * @param {boolean} [getCount] Set to \&quot;true\&quot; to only get the total number of results for given filters. limit/offset/order parameters will be ignored.
     * @param {string} [siriVehicleLocationIds]   Filter by siri vehicle location id. Comma-separated list of values.
     * @param {string} [siriSnapshotIds]   Filter by siri snapshot id. Comma-separated list of values.
     * @param {string} [siriRideStopIds]   Filter by siri ride stop id. Comma-separated list of values.
     * @param {string} [recordedAtTimeFrom]   Filter by recorded at time. Only return items which have date/time after or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
     * @param {string} [recordedAtTimeTo]   Filter by recorded at time. Only return items which have date/time before or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
     * @param {number} [lonGreaterOrEqual]   Filter by lon. Only return items which have a numeric value greater than or equal to given value  Example: 34.808
     * @param {number} [lonLowerOrEqual]   Filter by lon. Only return items which have a numeric value lower than or equal to given value  Example: 34.808
     * @param {number} [latGreaterOrEqual]   Filter by lat. Only return items which have a numeric value greater than or equal to given value  Example: 31.961
     * @param {number} [latLowerOrEqual]   Filter by lat. Only return items which have a numeric value lower than or equal to given value  Example: 31.961
     * @param {string} [orderBy] Order of the results. Comma-separated list of fields and direction. e.g. \&quot;field1 asc,field2 desc\&quot;.
     * @param {string} [siriRoutesLineRef]   Filter by siri route line ref. Only return items which exactly match given string.
     * @param {string} [siriRideVehicleRef]   Filter by siri ride vehicle ref. Only return items which exactly match given string.
     * @param {string} [siriRoutesOperatorRef]   Filter by siri route operator ref. Only return items which exactly match given string.
     * @param {string} [siriRidesSchedualedStartTimeFrom]   Filter by siri ride scheduled start time. Only return items which have date/time after or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
     * @param {string} [siriRidesSchedualedStartTimeTo]   Filter by siri ride scheduled start time. Only return items which have date/time before or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
     * @param {string} [siriRidesIds]   Filter by siri ride id. Comma-separated list of values.
     * @param {string} [siriRoutesIds]   Filter by siri route id. Comma-separated list of values.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiriApi
     */
    public listSiriVehicleLocationsListGet(limit?: number, offset?: number, getCount?: boolean, siriVehicleLocationIds?: string, siriSnapshotIds?: string, siriRideStopIds?: string, recordedAtTimeFrom?: string, recordedAtTimeTo?: string, lonGreaterOrEqual?: number, lonLowerOrEqual?: number, latGreaterOrEqual?: number, latLowerOrEqual?: number, orderBy?: string, siriRoutesLineRef?: string, siriRideVehicleRef?: string, siriRoutesOperatorRef?: string, siriRidesSchedualedStartTimeFrom?: string, siriRidesSchedualedStartTimeTo?: string, siriRidesIds?: string, siriRoutesIds?: string, options?: RawAxiosRequestConfig) {
        return SiriApiFp(this.configuration).listSiriVehicleLocationsListGet(limit, offset, getCount, siriVehicleLocationIds, siriSnapshotIds, siriRideStopIds, recordedAtTimeFrom, recordedAtTimeTo, lonGreaterOrEqual, lonLowerOrEqual, latGreaterOrEqual, latLowerOrEqual, orderBy, siriRoutesLineRef, siriRideVehicleRef, siriRoutesOperatorRef, siriRidesSchedualedStartTimeFrom, siriRidesSchedualedStartTimeTo, siriRidesIds, siriRoutesIds, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserCasesApi - axios parameter creator
 * @export
 */
export const UserCasesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List of A comparison between the planned and actual rides of a specific route between the given dates. Currently, the \"actual_rides_count\", will be either None (no actual ride) or equal to the \"planned_rides_count.
         * @summary List 
         * @param {string} dateFrom   Filter by date. Only return items which have a date after or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
         * @param {string} dateTo   Filter by date. Only return items which have a date before or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
         * @param {number} [limit] Limit the number of returned results. If not specified will limit to 100 results. To get more results, you can either use the offset param, alternatively - set the limit to -1 and use http streaming with compatible json streaming decoder to get all results, this method can fetch up to a maximum of 500000 results.
         * @param {number} [offset] Item number to start returning results from. Use in combination with limit for pagination, alternatively, don\&#39;t set offset, set limit to -1 and use http streaming with compatible json streaming decoder to get all results up to a maximum of 500000 results.
         * @param {boolean} [getCount] Set to \&quot;true\&quot; to only get the total number of results for given filters. limit/offset/order parameters will be ignored.
         * @param {number} [operatorRef] Line operator ref.  Filter by operator_ref. Only return items which exactly match given string.
         * @param {number} [lineRef] Line ref.  Filter by line_ref. Only return items which exactly match given string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRidesExecutionListGet: async (dateFrom: string, dateTo: string, limit?: number, offset?: number, getCount?: boolean, operatorRef?: number, lineRef?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dateFrom' is not null or undefined
            assertParamExists('listRidesExecutionListGet', 'dateFrom', dateFrom)
            // verify required parameter 'dateTo' is not null or undefined
            assertParamExists('listRidesExecutionListGet', 'dateTo', dateTo)
            const localVarPath = `/rides_execution/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (getCount !== undefined) {
                localVarQueryParameter['get_count'] = getCount;
            }

            if (dateFrom !== undefined) {
                localVarQueryParameter['date_from'] = (dateFrom as any instanceof Date) ?
                    (dateFrom as any).toISOString().substring(0,10) :
                    dateFrom;
            }

            if (dateTo !== undefined) {
                localVarQueryParameter['date_to'] = (dateTo as any instanceof Date) ?
                    (dateTo as any).toISOString().substring(0,10) :
                    dateTo;
            }

            if (operatorRef !== undefined) {
                localVarQueryParameter['operator_ref'] = operatorRef;
            }

            if (lineRef !== undefined) {
                localVarQueryParameter['line_ref'] = lineRef;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List of the stops timetable of a given bus. Currently, only planned time (gtfs) is returned for every stop.
         * @summary List 
         * @param {number} [limit] Limit the number of returned results. If not specified will limit to 100 results. To get more results, you can either use the offset param, alternatively - set the limit to -1 and use http streaming with compatible json streaming decoder to get all results, this method can fetch up to a maximum of 500000 results.
         * @param {number} [offset] Item number to start returning results from. Use in combination with limit for pagination, alternatively, don\&#39;t set offset, set limit to -1 and use http streaming with compatible json streaming decoder to get all results up to a maximum of 500000 results.
         * @param {boolean} [getCount] Set to \&quot;true\&quot; to only get the total number of results for given filters. limit/offset/order parameters will be ignored.
         * @param {string} [plannedStartTimeDateFrom] Set a time range to get the timetable of a specific ride  Filter by planned_start_time. Only return items which have date/time after or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
         * @param {string} [plannedStartTimeDateTo] Set a time range to get the time table of a specific ride  Filter by planned_start_time. Only return items which have date/time before or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
         * @param {string} [lineRefs] To get a line ref, first query gtfs_routes  Filter by line_ref. Comma-separated list of values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRouteTimetableListGet: async (limit?: number, offset?: number, getCount?: boolean, plannedStartTimeDateFrom?: string, plannedStartTimeDateTo?: string, lineRefs?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/route_timetable/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (getCount !== undefined) {
                localVarQueryParameter['get_count'] = getCount;
            }

            if (plannedStartTimeDateFrom !== undefined) {
                localVarQueryParameter['planned_start_time_date_from'] = (plannedStartTimeDateFrom as any instanceof Date) ?
                    (plannedStartTimeDateFrom as any).toISOString() :
                    plannedStartTimeDateFrom;
            }

            if (plannedStartTimeDateTo !== undefined) {
                localVarQueryParameter['planned_start_time_date_to'] = (plannedStartTimeDateTo as any instanceof Date) ?
                    (plannedStartTimeDateTo as any).toISOString() :
                    plannedStartTimeDateTo;
            }

            if (lineRefs !== undefined) {
                localVarQueryParameter['line_refs'] = lineRefs;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List of the actual arrival times to a specific stop. Currently, only planned time (gtfs) is returned for every stop.
         * @summary List 
         * @param {number} [limit] Limit the number of returned results. If not specified will limit to 100 results. To get more results, you can either use the offset param, alternatively - set the limit to -1 and use http streaming with compatible json streaming decoder to get all results, this method can fetch up to a maximum of 500000 results.
         * @param {number} [offset] Item number to start returning results from. Use in combination with limit for pagination, alternatively, don\&#39;t set offset, set limit to -1 and use http streaming with compatible json streaming decoder to get all results up to a maximum of 500000 results.
         * @param {boolean} [getCount] Set to \&quot;true\&quot; to only get the total number of results for given filters. limit/offset/order parameters will be ignored.
         * @param {number} [gtfsStopId] To get a line ref, first query gtfs_routes  Filter by gtfs_stop_id. Only return items which exactly match given string.
         * @param {string} [gtfsRideIds] To get a line ref, first query gtfs_routes  Filter by line_ref. Comma-separated list of values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listStopArrivalsListGet: async (limit?: number, offset?: number, getCount?: boolean, gtfsStopId?: number, gtfsRideIds?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/stop_arrivals/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (getCount !== undefined) {
                localVarQueryParameter['get_count'] = getCount;
            }

            if (gtfsStopId !== undefined) {
                localVarQueryParameter['gtfs_stop_id'] = gtfsStopId;
            }

            if (gtfsRideIds !== undefined) {
                localVarQueryParameter['gtfs_ride_ids'] = gtfsRideIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserCasesApi - functional programming interface
 * @export
 */
export const UserCasesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserCasesApiAxiosParamCreator(configuration)
    return {
        /**
         * List of A comparison between the planned and actual rides of a specific route between the given dates. Currently, the \"actual_rides_count\", will be either None (no actual ride) or equal to the \"planned_rides_count.
         * @summary List 
         * @param {string} dateFrom   Filter by date. Only return items which have a date after or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
         * @param {string} dateTo   Filter by date. Only return items which have a date before or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
         * @param {number} [limit] Limit the number of returned results. If not specified will limit to 100 results. To get more results, you can either use the offset param, alternatively - set the limit to -1 and use http streaming with compatible json streaming decoder to get all results, this method can fetch up to a maximum of 500000 results.
         * @param {number} [offset] Item number to start returning results from. Use in combination with limit for pagination, alternatively, don\&#39;t set offset, set limit to -1 and use http streaming with compatible json streaming decoder to get all results up to a maximum of 500000 results.
         * @param {boolean} [getCount] Set to \&quot;true\&quot; to only get the total number of results for given filters. limit/offset/order parameters will be ignored.
         * @param {number} [operatorRef] Line operator ref.  Filter by operator_ref. Only return items which exactly match given string.
         * @param {number} [lineRef] Line ref.  Filter by line_ref. Only return items which exactly match given string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRidesExecutionListGet(dateFrom: string, dateTo: string, limit?: number, offset?: number, getCount?: boolean, operatorRef?: number, lineRef?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RideExecutionPydanticModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRidesExecutionListGet(dateFrom, dateTo, limit, offset, getCount, operatorRef, lineRef, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserCasesApi.listRidesExecutionListGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List of the stops timetable of a given bus. Currently, only planned time (gtfs) is returned for every stop.
         * @summary List 
         * @param {number} [limit] Limit the number of returned results. If not specified will limit to 100 results. To get more results, you can either use the offset param, alternatively - set the limit to -1 and use http streaming with compatible json streaming decoder to get all results, this method can fetch up to a maximum of 500000 results.
         * @param {number} [offset] Item number to start returning results from. Use in combination with limit for pagination, alternatively, don\&#39;t set offset, set limit to -1 and use http streaming with compatible json streaming decoder to get all results up to a maximum of 500000 results.
         * @param {boolean} [getCount] Set to \&quot;true\&quot; to only get the total number of results for given filters. limit/offset/order parameters will be ignored.
         * @param {string} [plannedStartTimeDateFrom] Set a time range to get the timetable of a specific ride  Filter by planned_start_time. Only return items which have date/time after or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
         * @param {string} [plannedStartTimeDateTo] Set a time range to get the time table of a specific ride  Filter by planned_start_time. Only return items which have date/time before or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
         * @param {string} [lineRefs] To get a line ref, first query gtfs_routes  Filter by line_ref. Comma-separated list of values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRouteTimetableListGet(limit?: number, offset?: number, getCount?: boolean, plannedStartTimeDateFrom?: string, plannedStartTimeDateTo?: string, lineRefs?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RouteTimetablePydanticModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRouteTimetableListGet(limit, offset, getCount, plannedStartTimeDateFrom, plannedStartTimeDateTo, lineRefs, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserCasesApi.listRouteTimetableListGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List of the actual arrival times to a specific stop. Currently, only planned time (gtfs) is returned for every stop.
         * @summary List 
         * @param {number} [limit] Limit the number of returned results. If not specified will limit to 100 results. To get more results, you can either use the offset param, alternatively - set the limit to -1 and use http streaming with compatible json streaming decoder to get all results, this method can fetch up to a maximum of 500000 results.
         * @param {number} [offset] Item number to start returning results from. Use in combination with limit for pagination, alternatively, don\&#39;t set offset, set limit to -1 and use http streaming with compatible json streaming decoder to get all results up to a maximum of 500000 results.
         * @param {boolean} [getCount] Set to \&quot;true\&quot; to only get the total number of results for given filters. limit/offset/order parameters will be ignored.
         * @param {number} [gtfsStopId] To get a line ref, first query gtfs_routes  Filter by gtfs_stop_id. Only return items which exactly match given string.
         * @param {string} [gtfsRideIds] To get a line ref, first query gtfs_routes  Filter by line_ref. Comma-separated list of values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listStopArrivalsListGet(limit?: number, offset?: number, getCount?: boolean, gtfsStopId?: number, gtfsRideIds?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StopArrivalPydanticModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listStopArrivalsListGet(limit, offset, getCount, gtfsStopId, gtfsRideIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserCasesApi.listStopArrivalsListGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserCasesApi - factory interface
 * @export
 */
export const UserCasesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserCasesApiFp(configuration)
    return {
        /**
         * List of A comparison between the planned and actual rides of a specific route between the given dates. Currently, the \"actual_rides_count\", will be either None (no actual ride) or equal to the \"planned_rides_count.
         * @summary List 
         * @param {string} dateFrom   Filter by date. Only return items which have a date after or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
         * @param {string} dateTo   Filter by date. Only return items which have a date before or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
         * @param {number} [limit] Limit the number of returned results. If not specified will limit to 100 results. To get more results, you can either use the offset param, alternatively - set the limit to -1 and use http streaming with compatible json streaming decoder to get all results, this method can fetch up to a maximum of 500000 results.
         * @param {number} [offset] Item number to start returning results from. Use in combination with limit for pagination, alternatively, don\&#39;t set offset, set limit to -1 and use http streaming with compatible json streaming decoder to get all results up to a maximum of 500000 results.
         * @param {boolean} [getCount] Set to \&quot;true\&quot; to only get the total number of results for given filters. limit/offset/order parameters will be ignored.
         * @param {number} [operatorRef] Line operator ref.  Filter by operator_ref. Only return items which exactly match given string.
         * @param {number} [lineRef] Line ref.  Filter by line_ref. Only return items which exactly match given string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRidesExecutionListGet(dateFrom: string, dateTo: string, limit?: number, offset?: number, getCount?: boolean, operatorRef?: number, lineRef?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<RideExecutionPydanticModel>> {
            return localVarFp.listRidesExecutionListGet(dateFrom, dateTo, limit, offset, getCount, operatorRef, lineRef, options).then((request) => request(axios, basePath));
        },
        /**
         * List of the stops timetable of a given bus. Currently, only planned time (gtfs) is returned for every stop.
         * @summary List 
         * @param {number} [limit] Limit the number of returned results. If not specified will limit to 100 results. To get more results, you can either use the offset param, alternatively - set the limit to -1 and use http streaming with compatible json streaming decoder to get all results, this method can fetch up to a maximum of 500000 results.
         * @param {number} [offset] Item number to start returning results from. Use in combination with limit for pagination, alternatively, don\&#39;t set offset, set limit to -1 and use http streaming with compatible json streaming decoder to get all results up to a maximum of 500000 results.
         * @param {boolean} [getCount] Set to \&quot;true\&quot; to only get the total number of results for given filters. limit/offset/order parameters will be ignored.
         * @param {string} [plannedStartTimeDateFrom] Set a time range to get the timetable of a specific ride  Filter by planned_start_time. Only return items which have date/time after or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
         * @param {string} [plannedStartTimeDateTo] Set a time range to get the time table of a specific ride  Filter by planned_start_time. Only return items which have date/time before or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
         * @param {string} [lineRefs] To get a line ref, first query gtfs_routes  Filter by line_ref. Comma-separated list of values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRouteTimetableListGet(limit?: number, offset?: number, getCount?: boolean, plannedStartTimeDateFrom?: string, plannedStartTimeDateTo?: string, lineRefs?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<RouteTimetablePydanticModel>> {
            return localVarFp.listRouteTimetableListGet(limit, offset, getCount, plannedStartTimeDateFrom, plannedStartTimeDateTo, lineRefs, options).then((request) => request(axios, basePath));
        },
        /**
         * List of the actual arrival times to a specific stop. Currently, only planned time (gtfs) is returned for every stop.
         * @summary List 
         * @param {number} [limit] Limit the number of returned results. If not specified will limit to 100 results. To get more results, you can either use the offset param, alternatively - set the limit to -1 and use http streaming with compatible json streaming decoder to get all results, this method can fetch up to a maximum of 500000 results.
         * @param {number} [offset] Item number to start returning results from. Use in combination with limit for pagination, alternatively, don\&#39;t set offset, set limit to -1 and use http streaming with compatible json streaming decoder to get all results up to a maximum of 500000 results.
         * @param {boolean} [getCount] Set to \&quot;true\&quot; to only get the total number of results for given filters. limit/offset/order parameters will be ignored.
         * @param {number} [gtfsStopId] To get a line ref, first query gtfs_routes  Filter by gtfs_stop_id. Only return items which exactly match given string.
         * @param {string} [gtfsRideIds] To get a line ref, first query gtfs_routes  Filter by line_ref. Comma-separated list of values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listStopArrivalsListGet(limit?: number, offset?: number, getCount?: boolean, gtfsStopId?: number, gtfsRideIds?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<StopArrivalPydanticModel>> {
            return localVarFp.listStopArrivalsListGet(limit, offset, getCount, gtfsStopId, gtfsRideIds, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserCasesApi - object-oriented interface
 * @export
 * @class UserCasesApi
 * @extends {BaseAPI}
 */
export class UserCasesApi extends BaseAPI {
    /**
     * List of A comparison between the planned and actual rides of a specific route between the given dates. Currently, the \"actual_rides_count\", will be either None (no actual ride) or equal to the \"planned_rides_count.
     * @summary List 
     * @param {string} dateFrom   Filter by date. Only return items which have a date after or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
     * @param {string} dateTo   Filter by date. Only return items which have a date before or equals to given value. Format: \&quot;YYYY-MM-DD\&quot;, e.g. \&quot;2021-11-03\&quot;.
     * @param {number} [limit] Limit the number of returned results. If not specified will limit to 100 results. To get more results, you can either use the offset param, alternatively - set the limit to -1 and use http streaming with compatible json streaming decoder to get all results, this method can fetch up to a maximum of 500000 results.
     * @param {number} [offset] Item number to start returning results from. Use in combination with limit for pagination, alternatively, don\&#39;t set offset, set limit to -1 and use http streaming with compatible json streaming decoder to get all results up to a maximum of 500000 results.
     * @param {boolean} [getCount] Set to \&quot;true\&quot; to only get the total number of results for given filters. limit/offset/order parameters will be ignored.
     * @param {number} [operatorRef] Line operator ref.  Filter by operator_ref. Only return items which exactly match given string.
     * @param {number} [lineRef] Line ref.  Filter by line_ref. Only return items which exactly match given string.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserCasesApi
     */
    public listRidesExecutionListGet(dateFrom: string, dateTo: string, limit?: number, offset?: number, getCount?: boolean, operatorRef?: number, lineRef?: number, options?: RawAxiosRequestConfig) {
        return UserCasesApiFp(this.configuration).listRidesExecutionListGet(dateFrom, dateTo, limit, offset, getCount, operatorRef, lineRef, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List of the stops timetable of a given bus. Currently, only planned time (gtfs) is returned for every stop.
     * @summary List 
     * @param {number} [limit] Limit the number of returned results. If not specified will limit to 100 results. To get more results, you can either use the offset param, alternatively - set the limit to -1 and use http streaming with compatible json streaming decoder to get all results, this method can fetch up to a maximum of 500000 results.
     * @param {number} [offset] Item number to start returning results from. Use in combination with limit for pagination, alternatively, don\&#39;t set offset, set limit to -1 and use http streaming with compatible json streaming decoder to get all results up to a maximum of 500000 results.
     * @param {boolean} [getCount] Set to \&quot;true\&quot; to only get the total number of results for given filters. limit/offset/order parameters will be ignored.
     * @param {string} [plannedStartTimeDateFrom] Set a time range to get the timetable of a specific ride  Filter by planned_start_time. Only return items which have date/time after or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
     * @param {string} [plannedStartTimeDateTo] Set a time range to get the time table of a specific ride  Filter by planned_start_time. Only return items which have date/time before or equals to given value. Format: \&quot;YYYY-MM-DDTHH:MM:SS+Z\&quot;, e.g. \&quot;2021-11-03T15:48:49+02:00\&quot;. Note that all date/times must have a timezone specification.
     * @param {string} [lineRefs] To get a line ref, first query gtfs_routes  Filter by line_ref. Comma-separated list of values.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserCasesApi
     */
    public listRouteTimetableListGet(limit?: number, offset?: number, getCount?: boolean, plannedStartTimeDateFrom?: string, plannedStartTimeDateTo?: string, lineRefs?: string, options?: RawAxiosRequestConfig) {
        return UserCasesApiFp(this.configuration).listRouteTimetableListGet(limit, offset, getCount, plannedStartTimeDateFrom, plannedStartTimeDateTo, lineRefs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List of the actual arrival times to a specific stop. Currently, only planned time (gtfs) is returned for every stop.
     * @summary List 
     * @param {number} [limit] Limit the number of returned results. If not specified will limit to 100 results. To get more results, you can either use the offset param, alternatively - set the limit to -1 and use http streaming with compatible json streaming decoder to get all results, this method can fetch up to a maximum of 500000 results.
     * @param {number} [offset] Item number to start returning results from. Use in combination with limit for pagination, alternatively, don\&#39;t set offset, set limit to -1 and use http streaming with compatible json streaming decoder to get all results up to a maximum of 500000 results.
     * @param {boolean} [getCount] Set to \&quot;true\&quot; to only get the total number of results for given filters. limit/offset/order parameters will be ignored.
     * @param {number} [gtfsStopId] To get a line ref, first query gtfs_routes  Filter by gtfs_stop_id. Only return items which exactly match given string.
     * @param {string} [gtfsRideIds] To get a line ref, first query gtfs_routes  Filter by line_ref. Comma-separated list of values.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserCasesApi
     */
    public listStopArrivalsListGet(limit?: number, offset?: number, getCount?: boolean, gtfsStopId?: number, gtfsRideIds?: string, options?: RawAxiosRequestConfig) {
        return UserCasesApiFp(this.configuration).listStopArrivalsListGet(limit, offset, getCount, gtfsStopId, gtfsRideIds, options).then((request) => request(this.axios, this.basePath));
    }
}



